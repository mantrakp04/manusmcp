{
  "nodes": [
    {
      "id": "sqliteAgentMemory_0",
      "position": {
        "x": 378.27438279911416,
        "y": 721.5502841644658
      },
      "type": "customNode",
      "data": {
        "id": "sqliteAgentMemory_0",
        "label": "SQLite Agent Memory",
        "version": 1,
        "name": "sqliteAgentMemory",
        "type": "SQLiteAgentMemory",
        "baseClasses": [
          "SQLiteAgentMemory",
          "BaseCheckpointSaver"
        ],
        "category": "Memory",
        "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
        "inputParams": [
          {
            "label": "Additional Connection Configuration",
            "name": "additionalConfig",
            "type": "json",
            "additionalParams": true,
            "optional": true,
            "id": "sqliteAgentMemory_0-input-additionalConfig-json"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "additionalConfig": ""
        },
        "outputAnchors": [
          {
            "id": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
            "name": "sqliteAgentMemory",
            "label": "SQLiteAgentMemory",
            "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
            "type": "SQLiteAgentMemory | BaseCheckpointSaver"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "positionAbsolute": {
        "x": 378.27438279911416,
        "y": 721.5502841644658
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqStart_0",
      "position": {
        "x": 718.9582951853438,
        "y": 777.632429430604
      },
      "type": "customNode",
      "data": {
        "id": "seqStart_0",
        "label": "Start",
        "version": 2,
        "name": "seqStart",
        "type": "Start",
        "baseClasses": [
          "Start"
        ],
        "category": "Sequential Agents",
        "description": "Starting point of the conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "description": "Only compatible with models that are capable of function calling: ChatOpenAI, ChatMistral, ChatAnthropic, ChatGoogleGenerativeAI, ChatVertexAI, GroqChat",
            "id": "seqStart_0-input-model-BaseChatModel"
          },
          {
            "label": "Agent Memory",
            "name": "agentMemory",
            "type": "BaseCheckpointSaver",
            "description": "Save the state of the agent",
            "optional": true,
            "id": "seqStart_0-input-agentMemory-BaseCheckpointSaver"
          },
          {
            "label": "State",
            "name": "state",
            "type": "State",
            "description": "State is an object that is updated by nodes in the graph, passing from one node to another. By default, state contains \"messages\" that got updated with each message sent and received.",
            "optional": true,
            "id": "seqStart_0-input-state-State"
          },
          {
            "label": "Input Moderation",
            "description": "Detect text that could generate harmful output and prevent it from being sent to the language model",
            "name": "inputModeration",
            "type": "Moderation",
            "optional": true,
            "list": true,
            "id": "seqStart_0-input-inputModeration-Moderation"
          }
        ],
        "inputs": {
          "model": "{{chatAnthropic_0.data.instance}}",
          "agentMemory": "{{sqliteAgentMemory_0.data.instance}}",
          "state": "{{seqState_0.data.instance}}",
          "inputModeration": ""
        },
        "outputAnchors": [
          {
            "id": "seqStart_0-output-seqStart-Start",
            "name": "seqStart",
            "label": "Start",
            "description": "Starting point of the conversation",
            "type": "Start"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 383,
      "positionAbsolute": {
        "x": 718.9582951853438,
        "y": 777.632429430604
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqState_0",
      "position": {
        "x": 376.9253827409715,
        "y": 983.3661772343207
      },
      "type": "customNode",
      "data": {
        "id": "seqState_0",
        "label": "State",
        "version": 2,
        "name": "seqState",
        "type": "State",
        "baseClasses": [
          "State"
        ],
        "category": "Sequential Agents",
        "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
        "inputParams": [
          {
            "label": "Custom State",
            "name": "stateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedStateTab",
            "additionalParams": true,
            "default": "stateMemoryUI",
            "tabs": [
              {
                "label": "Custom State (Table)",
                "name": "stateMemoryUI",
                "type": "datagrid",
                "description": "Structure for state. By default, state contains \"messages\" that got updated with each message sent and received.",
                "hint": {
                  "label": "How to use",
                  "value": "\nSpecify the Key, Operation Type, and Default Value for the state object. The Operation Type can be either \"Replace\" or \"Append\".\n\n**Replace**\n- Replace the existing value with the new value.\n- If the new value is null, the existing value will be retained.\n\n**Append**\n- Append the new value to the existing value.\n- Default value can be empty or an array. Ex: [\"a\", \"b\"]\n- Final value is an array.\n"
                },
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "editable": true
                  },
                  {
                    "field": "type",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Replace",
                      "Append"
                    ],
                    "editable": true
                  },
                  {
                    "field": "defaultValue",
                    "headerName": "Default Value",
                    "flex": 1,
                    "editable": true
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Custom State (Code)",
                "name": "stateMemoryCode",
                "type": "code",
                "description": "JSON object representing the state",
                "hideCodeExecute": true,
                "codeExample": "{\n    aggregate: {\n        value: (x, y) => x.concat(y), // here we append the new message to the existing messages\n        default: () => []\n    }\n}",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqState_0-input-stateMemory-tabs"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "stateMemory": "stateMemoryUI",
          "stateMemoryUI": "[{\"key\":\"next\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":0},{\"key\":\"plan\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":1},{\"key\":\"instruction\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":2},{\"key\":\"sources\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":3},{\"key\":\"next_preview_path\",\"type\":\"Replace\",\"defaultValue\":\"[\\\"/\\\"]\",\"actions\":\"\",\"id\":4}]",
          "selectedStateTab_seqState_0": "stateMemoryUI",
          "stateMemoryCode": ""
        },
        "outputAnchors": [
          {
            "id": "seqState_0-output-seqState-State",
            "name": "seqState",
            "label": "State",
            "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
            "type": "State"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "selected": false,
      "positionAbsolute": {
        "x": 376.9253827409715,
        "y": 983.3661772343207
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_0",
      "position": {
        "x": 1108.8010149592337,
        "y": 755.6063662210681
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_0",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_0-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_0-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Supervisor",
          "systemMessagePrompt": "You are Supervisor, an AI agent created by BarrelOfLube.\n\nYou excel at the following tasks:\n1. Information gathering, fact-checking, documentation, ui generation.\n2. Data processing, analysis, and visualization\n3. Writing multi-chapter articles and in-depth research reports\n4. Creating websites, applications, and tools\n5. Using programming to solve various problems beyond development\n6. Various tasks that can be accomplished using computers and the internet\n\nDefault working language: English\nUse the language specified by user in messages as the working language when explicitly provided\nAll thinking and responses must be in the working language\nNatural language arguments in tool calls must be in the working language\nAvoid using pure lists and bullet points format in any language\n\nSystem capabilities:\n- Access a Linux sandbox environment with internet connection\n- Use shell, text editor, and other software\n- Write and run code in Python and various programming languages\n- Independently install required software packages and dependencies via shell\n- Access and browse the web\n- Utilize various tools to complete user-assigned tasks step by step\n\nCurrent Plan:\n{plan}\n\nYou operate in an agent loop, iteratively completing tasks through these steps:\n\n1. PLAN MANAGEMENT: \n   a) ALWAYS CHECK IF A PLAN EXISTS FIRST - If no plan exists or {plan} is empty, your FIRST action must be to invoke PlanManager to create a comprehensive plan\n   b) After completing any major task or milestone, invoke PlanManager to update the plan with progress\n   c) If you encounter obstacles or the requirements change, update the plan accordingly\n\n2. TASK DECOMPOSITION: Break down complex requests into logical sequential steps. For content creation tasks, ALWAYS follow this sequence:\n   a) Research and data gathering (using WebNavigator or Knowledgebase) FIRST\n   b) Analysis and synthesis of collected information\n   c) Content creation (using FileSystemManager) ONLY AFTER sufficient information is gathered\n   d) Review and refinement\n\n3. TOOL SELECTION: Choose the appropriate tool for each step:\n   - PlanManager: For creating initial plans and updating plans after major steps are completed\n   - WebNavigator: For online research, browsing websites, gathering current information\n   - Knowledgebase: For accessing stored knowledge on topics\n   - CommandRunner: For executing shell commands, installing packages, running scripts\n   - FileSystemManager: For creating, reading, or modifying files AFTER research phase\n   - MessageNotifyUser: For providing updates to the user\n   - MessageAskUser: For requesting additional information/clarification\n\n4. MESSAGE TOOL FORMATTING:\n   - When using MessageNotifyUser or MessageAskUser, write the COMPLETE, message text in the instruction field\n   - These tools pass your instruction text DIRECTLY to the user without any additional processing\n   - For MessageNotifyUser: Write a complete, informative update about progress or results\n   - For MessageAskUser: Write a clear, specific question with all necessary context included. DO NOT over-rely on this, only ask invoke if absolutley necessary.\n\n5. CONTEXT AWARENESS: Maintain awareness of the overall task context:\n   - For research tasks, gather comprehensive information before proceeding to content creation\n   - For multi-topic reports, research each major section thoroughly before writing\n   - Check with user after completing major task components\n   - After completing any significant step in the plan, update the plan with the new status\n\n6. EXECUTION: Execute one tool action per iteration and analyze results before proceeding\n   - Include sufficient context in each tool instruction\n   - For WebNavigator, provide detailed search instructions\n   - For FileSystemManager, only send after sufficient research is complete\n   - When using PlanManager for updates, clearly indicate which tasks are completed and which are pending\n\n7. COMPLETION: Only enter FINISH state when all tasks are fully completed with satisfactory results\n\nIMPORTANT PLAN STATUS RULES:\n1. If you receive a new user request and {plan} is empty, IMMEDIATELY invoke PlanManager first\n2. After completing ANY significant milestone in your plan, invoke PlanManager to update it\n3. Include progress updates in the plan (âœ… for completed tasks, â¬œ for pending tasks)\n4. The plan should always reflect the current state of the task",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqStart_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"plan\":\"$flow.state.plan\"}",
          "llmStructuredOutput": "[{\"key\":\"next\",\"type\":\"Enum\",\"enumValues\":\"FINISH, FileSystemManager, CommandRunner, WebNavigator, PlanManager, Knowledgebase, MessageAskUser, MessageNotifyUser\",\"description\":\"\",\"actions\":\"\",\"id\":0},{\"key\":\"instruction\",\"type\":\"String\",\"enumValues\":\"\",\"description\":\"The specific instructions of the sub-task the next role should accomplish.\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"next\",\"value\":\"$flow.output.next\",\"actions\":\"\",\"id\":0},{\"key\":\"instruction\",\"value\":\"$flow.output.instruction\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_0-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 1108.8010149592337,
        "y": 755.6063662210681
      },
      "dragging": false
    },
    {
      "id": "seqCondition_0",
      "position": {
        "x": 1434.356923525982,
        "y": 755.1665673275611
      },
      "type": "customNode",
      "data": {
        "id": "seqCondition_0",
        "label": "Condition",
        "version": 2.1,
        "name": "seqCondition",
        "type": "Condition",
        "baseClasses": [
          "Condition"
        ],
        "category": "Sequential Agents",
        "description": "Conditional function to determine which route to take next",
        "inputParams": [
          {
            "label": "Condition Name",
            "name": "conditionName",
            "type": "string",
            "optional": true,
            "placeholder": "If X, then Y",
            "id": "seqCondition_0-input-conditionName-string"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const state = $flow.state;\n                \nconst messages = state.messages;\n\nconst lastMessage = messages[messages.length - 1];\n\n/* Check if the last message has content */\nif (lastMessage.content) {\n    return \"Agent\";\n}\n\nreturn \"End\";",
                "optional": true
              }
            ],
            "id": "seqCondition_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "conditionName": "router",
          "sequentialNode": [
            "{{seqLLMNode_0.data.instance}}"
          ],
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"FileSystemManager\",\"output\":\"FileSystemManager\",\"actions\":\"\",\"id\":0},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"CommandRunner\",\"output\":\"CommandRunner\",\"actions\":\"\",\"id\":1},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"WebNavigator\",\"output\":\"WebNavigator\",\"actions\":\"\",\"id\":2},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"PlanManager\",\"output\":\"PlanManager\",\"actions\":\"\",\"id\":3},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"Knowledgebase\",\"output\":\"Knowledgebase\",\"actions\":\"\",\"id\":4},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"MessageNotifyUser\",\"output\":\"MessageNotifyUser\",\"actions\":\"\",\"id\":5},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"MessageAskUser\",\"output\":\"MessageAskUser\",\"actions\":\"\",\"id\":6}]",
          "selectedConditionFunctionTab_seqCondition_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqCondition_0-output-commandrunner-Condition",
                "name": "commandrunner",
                "label": "CommandRunner",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-filesystemmanager-Condition",
                "name": "filesystemmanager",
                "label": "FileSystemManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-knowledgebase-Condition",
                "name": "knowledgebase",
                "label": "Knowledgebase",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-messageaskuser-Condition",
                "name": "messageaskuser",
                "label": "MessageAskUser",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-messagenotifyuser-Condition",
                "name": "messagenotifyuser",
                "label": "MessageNotifyUser",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-planmanager-Condition",
                "name": "planmanager",
                "label": "PlanManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-webnavigator-Condition",
                "name": "webnavigator",
                "label": "WebNavigator",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 779,
      "positionAbsolute": {
        "x": 1434.356923525982,
        "y": 755.1665673275611
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqAgent_1",
      "position": {
        "x": 2124.887097839281,
        "y": -964.9762864330214
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_1",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_1-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_1-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_1-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_1-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_1-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "CommandRunner",
          "systemMessagePrompt": "You are a command-line expert who executes shell commands and manages processes in Unix/Linux environments. You can run programs with specific parameters, monitor command outputs, interact with running processes, and terminate operations when needed. Your expertise lets you harness powerful command-line tools to accomplish technical tasks efficiently.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_2.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_1-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "selected": false,
      "positionAbsolute": {
        "x": 2124.887097839281,
        "y": -964.9762864330214
      },
      "dragging": false
    },
    {
      "id": "seqAgent_2",
      "position": {
        "x": 2124.9785924171115,
        "y": 3084.651875749589
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_2",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_2-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_2-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_2-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_2-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_2-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "WebNavigator",
          "systemMessagePrompt": "You are an expert internet researcher who excels at finding comprehensive, accurate, and up-to-date information online. Your capabilities include:\n\n1. Formulating effective search queries to retrieve relevant information\n2. Exploring multiple sources to gather comprehensive data\n3. Comparing information across different websites to verify accuracy\n4. Extracting specific details, statistics, and expert opinions\n5. Summarizing findings clearly and objectively\n\nWhen researching topics:\n- Start with broad searches to establish baseline understanding\n- Follow up with more specific queries to gather detailed information\n- Visit authoritative sources relevant to the topic (academic, industry, government)\n- Collect diverse viewpoints when appropriate\n- Organize information systematically by subtopics\n- Note source URLs for citation purposes\n\nWhen returning research results:\n- Summarize key findings\n- Highlight important data points\n- Note any conflicting information\n- Include source attribution\n\nRemember: Always conduct thorough research before returning to content creation tasks.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{braveSearchAPI_0.data.instance}}",
            "{{customMCP_0.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_2-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "selected": false,
      "positionAbsolute": {
        "x": 2124.9785924171115,
        "y": 3084.651875749589
      },
      "dragging": false
    },
    {
      "id": "seqLoop_0",
      "position": {
        "x": 2440.930791260258,
        "y": -351.1848845522786
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_0",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_0-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2440.930791260258,
        "y": -351.1848845522786
      },
      "dragging": false
    },
    {
      "id": "customMCP_0",
      "position": {
        "x": 1432.6769191678472,
        "y": 1543.9973082797674
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_0",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_0-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_0-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"uv\",\n  \"args\": [\n    \"run\", \"manusmcp\"\n  ]\n}",
          "mcpActions": "[\"browser_click\",\"browser_console_exec\",\"browser_console_view\",\"browser_input\",\"browser_move_mouse\",\"browser_navigate\",\"browser_press_key\",\"browser_scroll_down\",\"browser_scroll_up\",\"browser_select_option\",\"browser_view\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_0-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 826,
      "selected": false,
      "positionAbsolute": {
        "x": 1432.6769191678472,
        "y": 1543.9973082797674
      },
      "dragging": false
    },
    {
      "id": "braveSearchAPI_0",
      "position": {
        "x": 1435.1095997195316,
        "y": 2375.494574599078
      },
      "type": "customNode",
      "data": {
        "id": "braveSearchAPI_0",
        "label": "BraveSearch API",
        "version": 1,
        "name": "braveSearchAPI",
        "type": "BraveSearchAPI",
        "baseClasses": [
          "BraveSearchAPI",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "braveSearchApi"
            ],
            "id": "braveSearchAPI_0-input-credential-credential"
          }
        ],
        "inputAnchors": [],
        "inputs": {},
        "outputAnchors": [
          {
            "id": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
            "name": "braveSearchAPI",
            "label": "BraveSearchAPI",
            "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
            "type": "BraveSearchAPI | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 276,
      "selected": false,
      "positionAbsolute": {
        "x": 1435.1095997195316,
        "y": 2375.494574599078
      },
      "dragging": false
    },
    {
      "id": "customMCP_1",
      "position": {
        "x": 1434.0917276411833,
        "y": -603.3040642918886
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_1",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_1-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_1-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"uv\",\n  \"args\": [\n    \"run\", \"manusmcp\"\n  ]\n}",
          "mcpActions": "[\"file_find_by_name\",\"file_find_in_content\",\"file_read\",\"file_str_replace\",\"file_write\",\"file_read_image\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_1-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 686,
      "selected": false,
      "positionAbsolute": {
        "x": 1434.0917276411833,
        "y": -603.3040642918886
      },
      "dragging": false
    },
    {
      "id": "customMCP_2",
      "position": {
        "x": 1435.044113186425,
        "y": -1293.89709510179
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_2",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_2-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_2-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"uv\",\n  \"args\": [\n    \"run\", \"manusmcp\"\n  ]\n}",
          "mcpActions": "[\"shell_exec\",\"shell_kill_process\",\"shell_view\",\"shell_wait\",\"shell_write_to_process\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_2-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 683,
      "selected": false,
      "positionAbsolute": {
        "x": 1435.044113186425,
        "y": -1293.89709510179
      },
      "dragging": false
    },
    {
      "id": "seqEnd_0",
      "position": {
        "x": 2127.2134615601053,
        "y": -100.43137253520263
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_0",
        "label": "End",
        "version": 2.1,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "id": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqCondition_0.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2127.2134615601053,
        "y": -100.43137253520263
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_1",
      "position": {
        "x": 2124.2065747337106,
        "y": 2647.0409707823756
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_1",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_1-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_1-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "PlanManager",
          "systemMessagePrompt": "You are a strategic planning and plan management expert who specializes in breaking complex tasks into manageable steps with clear dependencies and tracking progress. Your role is to:\n\n1. Analyze user objectives thoroughly before planning\n2. Design efficient execution paths\n3. Present plans using structured markdown with checkable tasks and subtasks\n4. Track progress by updating task completion status\n5. Adapt plans when circumstances change\n\nYou will create and maintain structured plans with:\n\n- âœ… Completed tasks marked with checkboxes\n- â¬œ Pending tasks clearly identified\n\nBefore planning, evaluate task complexity:\n\n- For simple tasks (1-3 steps), provide direct guidance without formal planning\n- For moderately complex tasks (4-8 steps), create a streamlined plan with just main steps\n- For highly complex tasks (9+ steps or multiple dependencies), develop a comprehensive plan with full hierarchy and tracking\nAdjust planning verbosity proportionally to task complexity - simple tasks need minimal planning while complex tasks benefit from detailed structure.\n\nWhen developing plans:\n\n- Use hierarchical task breakdowns (main tasks â†’ subtasks â†’ action items)\n- Include measurable milestones to track progress\n- Provide multiple approaches when relevant, with pros/cons\n- Balance thoroughness with efficiency\n- Clarify ambiguous goals before detailed planning\n- Regularly update and adapt the plan as progress occurs\nYou will automatically use markdown formatting for all plans, including:\n- Task hierarchies with proper indentation\n- Checkboxes for completion tracking\n- Nested lists for subtasks\n- Bold and italic text for emphasis\n- Tables for comparing options when appropriate\n- Headers for organizing different plan sections\n\nAs tasks are completed, you will update the plan by checking off completed items and adjusting remaining tasks as needed.\n\nCurrent Plan:\n\n{current_plan}",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"current_plan\":\"$flow.state.plan\"}",
          "llmStructuredOutput": "[{\"key\":\"plan\",\"type\":\"String\",\"enumValues\":\"\",\"description\":\"The entire updated plan\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"plan\",\"value\":\"$flow.output.plan\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_1-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2124.2065747337106,
        "y": 2647.0409707823756
      },
      "dragging": false
    },
    {
      "id": "stickyNote_0",
      "position": {
        "x": 693.8049581117547,
        "y": 1658.3284651070535
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_0",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_0-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Upload your files here\n\nRun: \n```docker run -p 8000:8000 -d --rm --name unstructured-api downloads.unstructured.io/unstructured-io/unstructured-api:latest```\n\n\nWe directly bypass flowise's document uploader, as Unstructured is objectively better and simpler with inbuilt semantic splitting, this stuff should be popular like hot cakes i dunno why its not."
        },
        "outputAnchors": [
          {
            "id": "stickyNote_0-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 304,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 693.8049581117547,
        "y": 1658.3284651070535
      }
    },
    {
      "id": "retrieverTool_0",
      "position": {
        "x": 1433.6840919974452,
        "y": 89.93682401817523
      },
      "type": "customNode",
      "data": {
        "id": "retrieverTool_0",
        "label": "Retriever Tool",
        "version": 3,
        "name": "retrieverTool",
        "type": "RetrieverTool",
        "baseClasses": [
          "RetrieverTool",
          "DynamicTool",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Use a retriever as allowed tool for agent",
        "inputParams": [
          {
            "label": "Retriever Name",
            "name": "name",
            "type": "string",
            "placeholder": "search_state_of_union",
            "id": "retrieverTool_0-input-name-string"
          },
          {
            "label": "Retriever Description",
            "name": "description",
            "type": "string",
            "description": "When should agent uses to retrieve documents",
            "rows": 3,
            "placeholder": "Searches and returns documents regarding the state-of-the-union.",
            "id": "retrieverTool_0-input-description-string"
          },
          {
            "label": "Return Source Documents",
            "name": "returnSourceDocuments",
            "type": "boolean",
            "optional": true,
            "id": "retrieverTool_0-input-returnSourceDocuments-boolean"
          },
          {
            "label": "Additional Metadata Filter",
            "name": "retrieverToolMetadataFilter",
            "type": "json",
            "description": "Add additional metadata filter on top of the existing filter from vector store",
            "optional": true,
            "additionalParams": true,
            "hint": {
              "label": "What can you filter?",
              "value": "Add additional filters to vector store. You can also filter with flow config, including the current \"state\":\n- `$flow.sessionId`\n- `$flow.chatId`\n- `$flow.chatflowId`\n- `$flow.input`\n- `$flow.state`\n"
            },
            "id": "retrieverTool_0-input-retrieverToolMetadataFilter-json"
          }
        ],
        "inputAnchors": [
          {
            "label": "Retriever",
            "name": "retriever",
            "type": "BaseRetriever",
            "id": "retrieverTool_0-input-retriever-BaseRetriever"
          }
        ],
        "inputs": {
          "name": "search_knowledgebase",
          "description": "Searches and returns documents from the knowledgebase",
          "retriever": "{{documentStoreVS_0.data.instance}}",
          "returnSourceDocuments": true,
          "retrieverToolMetadataFilter": ""
        },
        "outputAnchors": [
          {
            "id": "retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable",
            "name": "retrieverTool",
            "label": "RetrieverTool",
            "description": "Use a retriever as allowed tool for agent",
            "type": "RetrieverTool | DynamicTool | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 656,
      "selected": false,
      "positionAbsolute": {
        "x": 1433.6840919974452,
        "y": 89.93682401817523
      },
      "dragging": false
    },
    {
      "id": "seqConditionAgent_0",
      "position": {
        "x": 2761.234113297669,
        "y": 597.272580667779
      },
      "type": "customNode",
      "data": {
        "id": "seqConditionAgent_0",
        "label": "Condition Agent",
        "version": 3.1,
        "name": "seqConditionAgent",
        "type": "ConditionAgent",
        "baseClasses": [
          "ConditionAgent"
        ],
        "category": "Sequential Agents",
        "description": "Uses an agent to determine which route to take next",
        "inputParams": [
          {
            "label": "Name",
            "name": "conditionAgentName",
            "type": "string",
            "placeholder": "Condition Agent",
            "id": "seqConditionAgent_0-input-conditionAgentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "default": "You are an expert customer support routing system.\nYour job is to detect whether a customer support representative is routing a user to the technical support team, or just responding conversationally.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and Human Prompt.",
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "default": "The previous conversation is an interaction between a customer support representative and a user.\nExtract whether the representative is routing the user to the technical support team, or just responding conversationally.\n\nIf representative want to route the user to the technical support team, respond only with the word \"TECHNICAL\".\nOtherwise, respond only with the word \"CONVERSATION\".\n\nRemember, only respond with one of the above words.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "conditionAgentStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conditionAgentStructuredOutput-datagrid"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Agent's JSON Key Output (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. If you want to use the Condition Agent's output for conditional checks, it is available as `$flow.output` with the following structure:\n\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, we can check if the agent's output contains specific keyword:\n    ```js\n    const result = $flow.output.content;\n    \n    if (result.includes(\"some-keyword\")) {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n    If Structured Output is enabled, `$flow.output` will be in the JSON format as defined in the Structured Output configuration:\n    ```json\n    {\n        \"foo\": 'var'\n    }\n    ```\n\n4. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n5. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output.content;\n\nif (result.includes(\"some-keyword\")) {\n    return \"Agent\";\n}\n\nreturn \"End\";\n",
                "optional": true
              }
            ],
            "id": "seqConditionAgent_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqConditionAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "conditionAgentName": "Check if docs relevant",
          "sequentialNode": [
            "{{seqToolNode_0.data.instance}}"
          ],
          "model": "",
          "systemMessagePrompt": "You are a grader assessing relevance of a retrieved document to a user question.\n\nHere is the retrieved document:\n{context}\n\nHere is the user question: {question}\n\nIf the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant.\n\nGive a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question.\n\nRemember, always use the extract tool to output only \"yes\" or \"no\"",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "The previous conversation is an interaction between a bot and a user.\nExtract whether the if the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant.\n\nGive a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question.\n\nIf document is relavant to question, respond only with the word \"yes\".\nOtherwise, respond only with the word \"no\".\n\nRemember, always use the extract tool to output only \"yes\" or \"no\"",
          "promptValues": "{\"context\":\"$flow.state.messages[-1].content\",\"question\":\"$flow.state.instruction\"}",
          "conditionAgentStructuredOutput": "[{\"key\":\"score\",\"type\":\"Enum\",\"enumValues\":\"yes, no\",\"description\":\"grading score\",\"actions\":\"\",\"id\":1}]",
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.output.score\",\"operation\":\"Is\",\"value\":\"yes\",\"output\":\"Generate\",\"actions\":\"\",\"id\":1},{\"variable\":\"$flow.output.score\",\"operation\":\"Is\",\"value\":\"no\",\"output\":\"Rewrite\",\"actions\":\"\",\"id\":2}]",
          "selectedConditionFunctionTab_seqConditionAgent_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqConditionAgent_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-generate-Condition",
                "name": "generate",
                "label": "Generate",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-rewrite-Condition",
                "name": "rewrite",
                "label": "Rewrite",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 629,
      "selected": false,
      "positionAbsolute": {
        "x": 2761.234113297669,
        "y": 597.272580667779
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_2",
      "position": {
        "x": 3078.4111092840094,
        "y": 596.9092961439228
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_2",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_2-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_2-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Generate",
          "systemMessagePrompt": "You are an expert at synthesizing information to answer questions comprehensively and accurately. Use the following retrieved context to formulate a thorough response.\n\nQuestion: {question}\n\nContext: {context}\n\nGuidelines for your answer:\n1. Directly address the question using information from the provided context\n2. Synthesize information from multiple sources when available\n3. Present information in a logical, structured manner\n4. Highlight key points and insights\n5. Acknowledge limitations in the provided context when relevant\n6. Include proper citations or references to source material\n7. Use clear, precise language appropriate to the topic\n\nIf the context doesn't contain sufficient information to answer the question completely, acknowledge this limitation while providing what information you can.\n\nAnswer:",
          "messageHistory": "",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "Given the user question and context, answer user query. Remember to includes sources and citations",
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"question\":\"$flow.state.instruction\",\"context\":\"$flow.state.sources\"}",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_2-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 3078.4111092840094,
        "y": 596.9092961439228
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_3",
      "position": {
        "x": 3079.6589516341282,
        "y": 1035.8137323671149
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_3",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_3-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_3-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_3-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_3-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Rewrite",
          "systemMessagePrompt": "You are an expert at query reformulation, skilled at transforming initial questions into more effective search queries. \n\nHere is the initial question:\n{question}\n\nWhen reformulating this query:\n1. Identify the core information need behind the question\n2. Remove unnecessary words or context that might limit search results\n3. Include relevant synonyms or alternative phrasings\n4. Break down complex questions into simpler components\n5. Add specific terms that would appear in relevant documents\n6. Consider domain-specific terminology that would improve results\n7. Structure the query to maximize retrieval of relevant information\n\nFormulate an improved question that will yield better search results:",
          "messageHistory": "",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "Look at the input and try to reason about the underlying semantic intent / meaning.\n\nHere is the initial question:\n{question} \n  \nFormulate an improved question:\n",
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"question\":\"$flow.state.instruction\"}",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_3-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 3079.6589516341282,
        "y": 1035.8137323671149
      },
      "dragging": false
    },
    {
      "id": "seqLoop_1",
      "position": {
        "x": 3399.297949954669,
        "y": 1228.2708362967778
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_1",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_1-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_3.data.instance}}"
          ],
          "loopToName": "Knowledgebase"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3399.297949954669,
        "y": 1228.2708362967778
      },
      "dragging": false
    },
    {
      "id": "documentStoreVS_0",
      "position": {
        "x": 1098.1979091499097,
        "y": -67.01285339775131
      },
      "type": "customNode",
      "data": {
        "id": "documentStoreVS_0",
        "label": "Document Store (Vector)",
        "version": 1,
        "name": "documentStoreVS",
        "type": "DocumentStoreVS",
        "baseClasses": [
          "DocumentStoreVS"
        ],
        "category": "Vector Stores",
        "description": "Search and retrieve documents from Document Store",
        "inputParams": [
          {
            "label": "Select Store",
            "name": "selectedStore",
            "type": "asyncOptions",
            "loadMethod": "listStores",
            "id": "documentStoreVS_0-input-selectedStore-asyncOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "selectedStore": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "",
            "options": [
              {
                "id": "documentStoreVS_0-output-retriever-BaseRetriever",
                "name": "retriever",
                "label": "Retriever",
                "description": "",
                "type": "BaseRetriever"
              },
              {
                "id": "documentStoreVS_0-output-vectorStore-VectorStore",
                "name": "vectorStore",
                "label": "Vector Store",
                "description": "",
                "type": "VectorStore"
              }
            ],
            "default": "retriever"
          }
        ],
        "outputs": {
          "output": "retriever"
        },
        "selected": false
      },
      "width": 300,
      "height": 312,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 1098.1979091499097,
        "y": -67.01285339775131
      }
    },
    {
      "id": "seqToolNode_0",
      "position": {
        "x": 2442.878651740237,
        "y": 598.542029871071
      },
      "type": "customNode",
      "data": {
        "id": "seqToolNode_0",
        "label": "Tool Node",
        "version": 2.1,
        "name": "seqToolNode",
        "type": "ToolNode",
        "baseClasses": [
          "ToolNode"
        ],
        "category": "Sequential Agents",
        "description": "Execute tool and return tool's output",
        "inputParams": [
          {
            "label": "Name",
            "name": "toolNodeName",
            "type": "string",
            "placeholder": "Tool",
            "id": "seqToolNode_0-input-toolNodeName-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Require approval before executing tools",
            "type": "boolean",
            "optional": true,
            "id": "seqToolNode_0-input-interrupt-boolean"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Tool Node's output as the value to update state, it is available as available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    | Key          | Value                                     |\n    |--------------|-------------------------------------------|\n    | sources      | `$flow.output[0].toolOutput`       |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "All Tools Output (array)",
                        "value": "$flow.output"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output[0].toolOutput"
                      },
                      {
                        "label": "First Tool Input Arguments (string | json)",
                        "value": "$flow.output[0].toolInput"
                      },
                      {
                        "label": "First Tool Returned Source Documents (array)",
                        "value": "$flow.output[0].sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the tool's output as the value to update state, it is available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    ```js\n    /* Assuming you have the following state:\n    {\n        \"sources\": null\n    }\n    */\n    \n    return {\n        \"sources\": $flow.output[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqToolNode_0-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqToolNode_0-input-tools-Tool"
          },
          {
            "label": "LLM Node",
            "name": "llmNode",
            "type": "LLMNode",
            "id": "seqToolNode_0-input-llmNode-LLMNode"
          }
        ],
        "inputs": {
          "tools": [
            "{{retrieverTool_0.data.instance}}"
          ],
          "llmNode": "{{seqLLMNode_4.data.instance}}",
          "toolNodeName": "Retrieve",
          "interrupt": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "selectedUpdateStateMemoryTab_seqToolNode_0": "updateStateMemoryCode",
          "updateStateMemoryCode": "const result = $flow.output;\n\nconst sourceDocuments = result[0].sourceDocuments || [];\n\n/*\n* Format into:\nabc\nsources: {source: 'a', page: 12}\n*/\nconst formattedSources = sourceDocuments.map(item => {\n        const pageContent = item.pageContent;\n        const metadata = `Sources: ${JSON.stringify(item.metadata)}`;\n        return `${pageContent}\\n${metadata}`;\n    }).join('\\n\\n');\n\nreturn {\n  sources: formattedSources\n};"
        },
        "outputAnchors": [
          {
            "id": "seqToolNode_0-output-seqToolNode-ToolNode",
            "name": "seqToolNode",
            "label": "ToolNode",
            "description": "Execute tool and return tool's output",
            "type": "ToolNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 529,
      "selected": false,
      "positionAbsolute": {
        "x": 2442.878651740237,
        "y": 598.542029871071
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_4",
      "position": {
        "x": 2121.576789562262,
        "y": 599.9223720832447
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_4",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_4-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_4-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_4-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_4-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Knowledgebase",
          "systemMessagePrompt": "You are an expert knowledgebase document analyst that always answers questions with the most relevant information using the tools at your disposal.",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_4-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2121.576789562262,
        "y": 599.9223720832447
      },
      "dragging": false
    },
    {
      "id": "seqLoop_2",
      "position": {
        "x": 3078.9532982262012,
        "y": -524.6740250853532
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_2",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_2-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3078.9532982262012,
        "y": -524.6740250853532
      },
      "dragging": false
    },
    {
      "id": "seqLoop_3",
      "position": {
        "x": 2439.9900504905204,
        "y": 2840.304510337466
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_3",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_3-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2439.9900504905204,
        "y": 2840.304510337466
      },
      "dragging": false
    },
    {
      "id": "seqLoop_4",
      "position": {
        "x": 2439.6303009227595,
        "y": 3707.4679031206488
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_4",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_4-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_2.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2439.6303009227595,
        "y": 3707.4679031206488
      },
      "dragging": false
    },
    {
      "id": "seqLoop_5",
      "position": {
        "x": 3400.075053686658,
        "y": 594.3985768694697
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_5",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_5-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_2.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3400.075053686658,
        "y": 594.3985768694697
      },
      "dragging": false
    },
    {
      "id": "seqCustomFunction_0",
      "position": {
        "x": 2123.664436816589,
        "y": 1845.5771179419667
      },
      "type": "customNode",
      "data": {
        "id": "seqCustomFunction_0",
        "label": "Custom JS Function",
        "version": 1,
        "name": "seqCustomFunction",
        "type": "CustomFunction",
        "baseClasses": [
          "CustomFunction"
        ],
        "category": "Sequential Agents",
        "description": "Execute custom javascript function",
        "inputParams": [
          {
            "label": "Input Variables",
            "name": "functionInputVariables",
            "description": "Input variables can be used in the function with prefix $. For example: $var",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqCustomFunction_0-input-functionInputVariables-json"
          },
          {
            "label": "Function Name",
            "name": "functionName",
            "type": "string",
            "placeholder": "My Function",
            "id": "seqCustomFunction_0-input-functionName-string"
          },
          {
            "label": "Javascript Function",
            "name": "javascriptFunction",
            "type": "code",
            "hint": {
              "label": "How to use",
              "value": "\n1. Must return a string value at the end of function.\n\n2. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n3. You can get custom variables: `$vars.<variable-name>`\n\n"
            },
            "id": "seqCustomFunction_0-input-javascriptFunction-code"
          },
          {
            "label": "Return Value As",
            "name": "returnValueAs",
            "type": "options",
            "options": [
              {
                "label": "AI Message",
                "name": "aiMessage"
              },
              {
                "label": "Human Message",
                "name": "humanMessage"
              },
              {
                "label": "State Object",
                "name": "stateObj",
                "description": "Return as state object, ex: { foo: bar }. This will update the custom state 'foo' to 'bar'"
              }
            ],
            "default": "aiMessage",
            "id": "seqCustomFunction_0-input-returnValueAs-options"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "functionInputVariables": "{\"instruction\":\"$flow.state.instruction\"}",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "functionName": "MessageNotifyUser",
          "javascriptFunction": "return String($instruction)",
          "returnValueAs": "aiMessage"
        },
        "outputAnchors": [
          {
            "id": "seqCustomFunction_0-output-seqCustomFunction-CustomFunction",
            "name": "seqCustomFunction",
            "label": "CustomFunction",
            "description": "Execute custom javascript function",
            "type": "CustomFunction"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 795,
      "selected": false,
      "positionAbsolute": {
        "x": 2123.664436816589,
        "y": 1845.5771179419667
      },
      "dragging": false
    },
    {
      "id": "seqLoop_6",
      "position": {
        "x": 2437.815563419601,
        "y": 2401.585197734329
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_6",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_6-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCustomFunction_0.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2437.815563419601,
        "y": 2401.585197734329
      },
      "dragging": false
    },
    {
      "id": "seqEnd_1",
      "position": {
        "x": 2439.039812130893,
        "y": 1693.141728557815
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_1",
        "label": "End",
        "version": 2.1,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "id": "seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqCustomFunction_1.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2439.039812130893,
        "y": 1693.141728557815
      },
      "dragging": false
    },
    {
      "id": "seqCustomFunction_1",
      "position": {
        "x": 2121.5792013052646,
        "y": 1042.3586428398544
      },
      "type": "customNode",
      "data": {
        "id": "seqCustomFunction_1",
        "label": "Custom JS Function",
        "version": 1,
        "name": "seqCustomFunction",
        "type": "CustomFunction",
        "baseClasses": [
          "CustomFunction"
        ],
        "category": "Sequential Agents",
        "description": "Execute custom javascript function",
        "inputParams": [
          {
            "label": "Input Variables",
            "name": "functionInputVariables",
            "description": "Input variables can be used in the function with prefix $. For example: $var",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqCustomFunction_1-input-functionInputVariables-json"
          },
          {
            "label": "Function Name",
            "name": "functionName",
            "type": "string",
            "placeholder": "My Function",
            "id": "seqCustomFunction_1-input-functionName-string"
          },
          {
            "label": "Javascript Function",
            "name": "javascriptFunction",
            "type": "code",
            "hint": {
              "label": "How to use",
              "value": "\n1. Must return a string value at the end of function.\n\n2. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n3. You can get custom variables: `$vars.<variable-name>`\n\n"
            },
            "id": "seqCustomFunction_1-input-javascriptFunction-code"
          },
          {
            "label": "Return Value As",
            "name": "returnValueAs",
            "type": "options",
            "options": [
              {
                "label": "AI Message",
                "name": "aiMessage"
              },
              {
                "label": "Human Message",
                "name": "humanMessage"
              },
              {
                "label": "State Object",
                "name": "stateObj",
                "description": "Return as state object, ex: { foo: bar }. This will update the custom state 'foo' to 'bar'"
              }
            ],
            "default": "aiMessage",
            "id": "seqCustomFunction_1-input-returnValueAs-options"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "functionInputVariables": "{\"instruction\":\"$flow.state.instruction\"}",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "functionName": "MessageAskUser",
          "javascriptFunction": "return String($instruction)",
          "returnValueAs": "aiMessage"
        },
        "outputAnchors": [
          {
            "id": "seqCustomFunction_1-output-seqCustomFunction-CustomFunction",
            "name": "seqCustomFunction",
            "label": "CustomFunction",
            "description": "Execute custom javascript function",
            "type": "CustomFunction"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 795,
      "selected": false,
      "positionAbsolute": {
        "x": 2121.5792013052646,
        "y": 1042.3586428398544
      },
      "dragging": false
    },
    {
      "id": "stickyNote_1",
      "position": {
        "x": 66.97275429770514,
        "y": 983.7498255438102
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_1",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_1-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Not adding long term chat memory because its not worth the effort, but feel free to add it.\n\nhttps://langchain-ai.github.io/langgraph/concepts/memory/#long-term-memory"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_1-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 163,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 66.97275429770514,
        "y": 983.7498255438102
      }
    },
    {
      "id": "plainText_0",
      "position": {
        "x": 376.2635886620957,
        "y": 1983.761408512896
      },
      "type": "customNode",
      "data": {
        "id": "plainText_0",
        "label": "Plain Text",
        "version": 2,
        "name": "plainText",
        "type": "Document",
        "baseClasses": [
          "Document"
        ],
        "category": "Document Loaders",
        "description": "Load data from plain text",
        "inputParams": [
          {
            "label": "Text",
            "name": "text",
            "type": "string",
            "rows": 4,
            "placeholder": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua...",
            "id": "plainText_0-input-text-string"
          },
          {
            "label": "Additional Metadata",
            "name": "metadata",
            "type": "json",
            "description": "Additional metadata to be added to the extracted documents",
            "optional": true,
            "additionalParams": true,
            "id": "plainText_0-input-metadata-json"
          },
          {
            "label": "Omit Metadata Keys",
            "name": "omitMetadataKeys",
            "type": "string",
            "rows": 4,
            "description": "Each document loader comes with a default set of metadata keys that are extracted from the document. You can use this field to omit some of the default metadata keys. The value should be a list of keys, seperated by comma. Use * to omit all metadata keys execept the ones you specify in the Additional Metadata field",
            "placeholder": "key1, key2, key3.nestedKey1",
            "optional": true,
            "additionalParams": true,
            "id": "plainText_0-input-omitMetadataKeys-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Text Splitter",
            "name": "textSplitter",
            "type": "TextSplitter",
            "optional": true,
            "id": "plainText_0-input-textSplitter-TextSplitter"
          }
        ],
        "inputs": {
          "text": "false",
          "textSplitter": "",
          "metadata": "",
          "omitMetadataKeys": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "Array of document objects containing metadata and pageContent",
            "options": [
              {
                "id": "plainText_0-output-document-Document|json",
                "name": "document",
                "label": "Document",
                "description": "Array of document objects containing metadata and pageContent",
                "type": "Document | json"
              },
              {
                "id": "plainText_0-output-text-string|json",
                "name": "text",
                "label": "Text",
                "description": "Concatenated string from pageContent of documents",
                "type": "string | json"
              }
            ],
            "default": "document"
          }
        ],
        "outputs": {
          "output": "text"
        },
        "selected": false
      },
      "width": 300,
      "height": 487,
      "positionAbsolute": {
        "x": 376.2635886620957,
        "y": 1983.761408512896
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "setVariable_1",
      "position": {
        "x": 693.8272478963587,
        "y": 1986.4217104601396
      },
      "type": "customNode",
      "data": {
        "id": "setVariable_1",
        "label": "Set Variable",
        "version": 2.1,
        "name": "setVariable",
        "type": "SetVariable",
        "baseClasses": [
          "SetVariable",
          "Utilities"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Set variable which can be retrieved at a later stage. Variable is only available during runtime.",
        "inputParams": [
          {
            "label": "Variable Name",
            "name": "variableName",
            "type": "string",
            "placeholder": "var1",
            "id": "setVariable_1-input-variableName-string"
          },
          {
            "label": "Show Output",
            "name": "showOutput",
            "description": "Show the output result in the Prediction API response",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "setVariable_1-input-showOutput-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Input",
            "name": "input",
            "type": "string | number | boolean | json | array",
            "optional": true,
            "list": true,
            "id": "setVariable_1-input-input-string | number | boolean | json | array"
          }
        ],
        "inputs": {
          "input": [
            "{{plainText_0.data.instance}}"
          ],
          "variableName": "is_nextjs_runtime_available",
          "showOutput": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "",
            "options": [
              {
                "id": "setVariable_1-output-output-string|number|boolean|json|array",
                "name": "output",
                "label": "Output",
                "description": "",
                "type": "string | number | boolean | json | array"
              }
            ],
            "default": "output"
          }
        ],
        "outputs": {
          "output": "output"
        },
        "selected": false
      },
      "width": 300,
      "height": 408,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 693.8272478963587,
        "y": 1986.4217104601396
      }
    },
    {
      "id": "stickyNote_2",
      "position": {
        "x": 378.14658030429007,
        "y": 1909.8763514699885
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_2",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_2-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Enable or disable nextjs runtime. Once enabled cannot be disabled"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_2-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 62,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 378.14658030429007,
        "y": 1909.8763514699885
      }
    },
    {
      "id": "stickyNote_3",
      "position": {
        "x": 1100.237693708882,
        "y": -152.88374394774792
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_3",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_3-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Add a document store here, to add multiple, duplicate from retriever tool. 1 store per tool"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_3-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 82,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 1100.237693708882,
        "y": -152.88374394774792
      }
    },
    {
      "id": "seqLLMNode_5",
      "position": {
        "x": 2127.6967217678325,
        "y": 51.29030790710431
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_5",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_5-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_5-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_5-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_5-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "FileSystemManager",
          "systemMessagePrompt": "You are a file system expert who can manipulate and organize digital content. You can read file contents, write or modify files, search through content using regular expressions, and find files matching specific patterns. Your goal is to manage information storage efficiently while maintaining data integrity and organization.\n\nIMPORTANT: Always pass empty string as content for file_write if the instructions of the message instructs to create a file and/or specify its contents.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_5-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2127.6967217678325,
        "y": 51.29030790710431
      },
      "dragging": false
    },
    {
      "id": "seqToolNode_1",
      "position": {
        "x": 2443.0444903587545,
        "y": 49.61782448259919
      },
      "type": "customNode",
      "data": {
        "id": "seqToolNode_1",
        "label": "Tool Node",
        "version": 2.1,
        "name": "seqToolNode",
        "type": "ToolNode",
        "baseClasses": [
          "ToolNode"
        ],
        "category": "Sequential Agents",
        "description": "Execute tool and return tool's output",
        "inputParams": [
          {
            "label": "Name",
            "name": "toolNodeName",
            "type": "string",
            "placeholder": "Tool",
            "id": "seqToolNode_1-input-toolNodeName-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Require approval before executing tools",
            "type": "boolean",
            "optional": true,
            "id": "seqToolNode_1-input-interrupt-boolean"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Tool Node's output as the value to update state, it is available as available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    | Key          | Value                                     |\n    |--------------|-------------------------------------------|\n    | sources      | `$flow.output[0].toolOutput`       |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "All Tools Output (array)",
                        "value": "$flow.output"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output[0].toolOutput"
                      },
                      {
                        "label": "First Tool Input Arguments (string | json)",
                        "value": "$flow.output[0].toolInput"
                      },
                      {
                        "label": "First Tool Returned Source Documents (array)",
                        "value": "$flow.output[0].sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the tool's output as the value to update state, it is available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    ```js\n    /* Assuming you have the following state:\n    {\n        \"sources\": null\n    }\n    */\n    \n    return {\n        \"sources\": $flow.output[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqToolNode_1-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqToolNode_1-input-tools-Tool"
          },
          {
            "label": "LLM Node",
            "name": "llmNode",
            "type": "LLMNode",
            "id": "seqToolNode_1-input-llmNode-LLMNode"
          }
        ],
        "inputs": {
          "tools": [
            "{{customMCP_1.data.instance}}"
          ],
          "llmNode": "{{seqLLMNode_5.data.instance}}",
          "toolNodeName": "fs",
          "interrupt": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqToolNode_1-output-seqToolNode-ToolNode",
            "name": "seqToolNode",
            "label": "ToolNode",
            "description": "Execute tool and return tool's output",
            "type": "ToolNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 529,
      "selected": false,
      "positionAbsolute": {
        "x": 2443.0444903587545,
        "y": 49.61782448259919
      },
      "dragging": false
    },
    {
      "id": "seqCondition_1",
      "position": {
        "x": 2753.8920173062575,
        "y": 8.525199911986874
      },
      "type": "customNode",
      "data": {
        "id": "seqCondition_1",
        "label": "Condition",
        "version": 2.1,
        "name": "seqCondition",
        "type": "Condition",
        "baseClasses": [
          "Condition"
        ],
        "category": "Sequential Agents",
        "description": "Conditional function to determine which route to take next",
        "inputParams": [
          {
            "label": "Condition Name",
            "name": "conditionName",
            "type": "string",
            "optional": true,
            "placeholder": "If X, then Y",
            "id": "seqCondition_1-input-conditionName-string"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const state = $flow.state;\n                \nconst messages = state.messages;\n\nconst lastMessage = messages[messages.length - 1];\n\n/* Check if the last message has content */\nif (lastMessage.content) {\n    return \"Agent\";\n}\n\nreturn \"End\";",
                "optional": true
              }
            ],
            "id": "seqCondition_1-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "conditionName": "return direct",
          "sequentialNode": [
            "{{seqToolNode_1.data.instance}}"
          ],
          "condition": "",
          "conditionFunction": "const state = $flow.state;\n                \nconst messages = state.messages;\nconst lastMessage = messages[messages.length - 1];\n/* Check if the last message has content */\nif (lastMessage.tool && [\"file_read\", \"file_read_image\"].includes(lastMessage.tool)) {\n    return \"true\";\n} else if (lastMessage.tool === \"file_write\" && lastMessage.toolOutput === \"\") {\n    return \"write_file_content\";\n} else if (lastMessage.tool && [].includes(lastMessage.tool)) {\n    return \"FileSystemManager\"\n}\nreturn \"false\";",
          "selectedConditionFunctionTab_seqCondition_1": "conditionFunction"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqCondition_1-output-filesystemmanager-Condition",
                "name": "filesystemmanager",
                "label": "FileSystemManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-false-Condition",
                "name": "false",
                "label": "false",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-true-Condition",
                "name": "true",
                "label": "true",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-write_file_content-Condition",
                "name": "write_file_content",
                "label": "write_file_content",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 577,
      "selected": false,
      "positionAbsolute": {
        "x": 2753.8920173062575,
        "y": 8.525199911986874
      },
      "dragging": false
    },
    {
      "id": "seqLoop_7",
      "position": {
        "x": 3708.1532125872936,
        "y": -523.1802281920122
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_7",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_7-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "FileSystemManager"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3708.1532125872936,
        "y": -523.1802281920122
      },
      "dragging": false
    },
    {
      "id": "seqAgent_0",
      "position": {
        "x": 3079.6558538620857,
        "y": -278.2435547172722
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_0",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_0-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_0-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_0-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_0-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_0-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "write_file_content",
          "systemMessagePrompt": "You are an expert at synthesizing content according to the provided instructions and conversation history.\n{instruction}\nWhen receiving a content creation instruction, assess whether adequate research has been done. If not, recommend returning to research phase first.\n\nFile write strategy: Overwrite contents",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_3.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{\"instruction\":\"$flow.state.instruction\"}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_0-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "positionAbsolute": {
        "x": 3079.6558538620857,
        "y": -278.2435547172722
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "customMCP_3",
      "position": {
        "x": 2747.5965157256787,
        "y": -652.9773525385908
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_3",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_3-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_3-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"uv\",\n  \"args\": [\n    \"run\", \"manusmcp\"\n  ]\n}",
          "mcpActions": "[\"file_write\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_3-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 546,
      "selected": false,
      "positionAbsolute": {
        "x": 2747.5965157256787,
        "y": -652.9773525385908
      },
      "dragging": false
    },
    {
      "id": "seqLoop_8",
      "position": {
        "x": 3399.925880127913,
        "y": 341.27391026223313
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_8",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_8-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_0.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3399.925880127913,
        "y": 341.27391026223313
      },
      "dragging": false
    },
    {
      "id": "stickyNote_4",
      "position": {
        "x": 3394.277115220276,
        "y": -280.2039355346219
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_4",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_4-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "This is an expensive api call as it uses the entire message history as its context, this we need extra logic to only invoke it when required."
        },
        "outputAnchors": [
          {
            "id": "stickyNote_4-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 103,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 3394.277115220276,
        "y": -280.2039355346219
      }
    },
    {
      "id": "seqLoop_9",
      "position": {
        "x": 3392.6618117394028,
        "y": -525.6660585939348
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_9",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_9-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3392.6618117394028,
        "y": -525.6660585939348
      },
      "dragging": false
    },
    {
      "id": "chatAnthropic_0",
      "position": {
        "x": 380.82696272640305,
        "y": 37.309099486363834
      },
      "type": "customNode",
      "data": {
        "id": "chatAnthropic_0",
        "label": "ChatAnthropic",
        "version": 8,
        "name": "chatAnthropic",
        "type": "ChatAnthropic",
        "baseClasses": [
          "ChatAnthropic",
          "ChatAnthropicMessages",
          "BaseChatModel",
          "BaseLanguageModel",
          "Runnable"
        ],
        "category": "Chat Models",
        "description": "Wrapper around ChatAnthropic large language models that use the Chat endpoint",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "anthropicApi"
            ],
            "id": "chatAnthropic_0-input-credential-credential"
          },
          {
            "label": "Model Name",
            "name": "modelName",
            "type": "asyncOptions",
            "loadMethod": "listModels",
            "default": "claude-3-haiku",
            "id": "chatAnthropic_0-input-modelName-asyncOptions"
          },
          {
            "label": "Temperature",
            "name": "temperature",
            "type": "number",
            "step": 0.1,
            "default": 0.9,
            "optional": true,
            "id": "chatAnthropic_0-input-temperature-number"
          },
          {
            "label": "Streaming",
            "name": "streaming",
            "type": "boolean",
            "default": true,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-streaming-boolean"
          },
          {
            "label": "Max Tokens",
            "name": "maxTokensToSample",
            "type": "number",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-maxTokensToSample-number"
          },
          {
            "label": "Top P",
            "name": "topP",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-topP-number"
          },
          {
            "label": "Top K",
            "name": "topK",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-topK-number"
          },
          {
            "label": "Extended Thinking",
            "name": "extendedThinking",
            "type": "boolean",
            "description": "Enable extended thinking for reasoning model such as Claude Sonnet 3.7",
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-extendedThinking-boolean"
          },
          {
            "label": "Budget Tokens",
            "name": "budgetTokens",
            "type": "number",
            "step": 1,
            "default": 1024,
            "description": "Maximum number of tokens Claude is allowed use for its internal reasoning process",
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-budgetTokens-number"
          },
          {
            "label": "Allow Image Uploads",
            "name": "allowImageUploads",
            "type": "boolean",
            "description": "Allow image input. Refer to the <a href=\"https://docs.flowiseai.com/using-flowise/uploads#image\" target=\"_blank\">docs</a> for more details.",
            "default": false,
            "optional": true,
            "id": "chatAnthropic_0-input-allowImageUploads-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Cache",
            "name": "cache",
            "type": "BaseCache",
            "optional": true,
            "id": "chatAnthropic_0-input-cache-BaseCache"
          }
        ],
        "inputs": {
          "cache": "",
          "modelName": "claude-3-5-sonnet-latest",
          "temperature": "0.2",
          "streaming": true,
          "maxTokensToSample": "",
          "topP": "",
          "topK": "",
          "extendedThinking": "",
          "budgetTokens": 1024,
          "allowImageUploads": true
        },
        "outputAnchors": [
          {
            "id": "chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable",
            "name": "chatAnthropic",
            "label": "ChatAnthropic",
            "description": "Wrapper around ChatAnthropic large language models that use the Chat endpoint",
            "type": "ChatAnthropic | ChatAnthropicMessages | BaseChatModel | BaseLanguageModel | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 670,
      "selected": false,
      "positionAbsolute": {
        "x": 380.82696272640305,
        "y": 37.309099486363834
      },
      "dragging": false
    }
  ],
  "edges": [
    {
      "source": "sqliteAgentMemory_0",
      "sourceHandle": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "type": "buttonedge",
      "id": "sqliteAgentMemory_0-sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver-seqStart_0-seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "selected": false
    },
    {
      "source": "seqState_0",
      "sourceHandle": "seqState_0-output-seqState-State",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-state-State",
      "type": "buttonedge",
      "id": "seqState_0-seqState_0-output-seqState-State-seqStart_0-seqStart_0-input-state-State",
      "selected": false
    },
    {
      "source": "seqLLMNode_0",
      "sourceHandle": "seqLLMNode_0-output-seqLLMNode-LLMNode",
      "target": "seqCondition_0",
      "targetHandle": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_0-seqLLMNode_0-output-seqLLMNode-LLMNode-seqCondition_0-seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "braveSearchAPI_0",
      "sourceHandle": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "braveSearchAPI_0-braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable-seqAgent_2-seqAgent_2-input-tools-Tool",
      "selected": false
    },
    {
      "source": "customMCP_0",
      "sourceHandle": "customMCP_0-output-customMCP-Tool",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_0-customMCP_0-output-customMCP-Tool-seqAgent_2-seqAgent_2-input-tools-Tool",
      "selected": false
    },
    {
      "source": "customMCP_2",
      "sourceHandle": "customMCP_2-output-customMCP-Tool",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_2-customMCP_2-output-customMCP-Tool-seqAgent_1-seqAgent_1-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-webnavigator-Condition",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-webnavigator-Condition-seqAgent_2-seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-commandrunner-Condition",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-commandrunner-Condition-seqAgent_1-seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-end-Condition",
      "target": "seqEnd_0",
      "targetHandle": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-end-Condition-seqEnd_0-seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-planmanager-Condition",
      "target": "seqLLMNode_1",
      "targetHandle": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-planmanager-Condition-seqLLMNode_1-seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqAgent_1",
      "sourceHandle": "seqAgent_1-output-seqAgent-Agent",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_1-seqAgent_1-output-seqAgent-Agent-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqLLMNode_3",
      "sourceHandle": "seqLLMNode_3-output-seqLLMNode-LLMNode",
      "target": "seqLoop_1",
      "targetHandle": "seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_3-seqLLMNode_3-output-seqLLMNode-LLMNode-seqLoop_1-seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-rewrite-Condition",
      "target": "seqLLMNode_3",
      "targetHandle": "seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-rewrite-Condition-seqLLMNode_3-seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-generate-Condition",
      "target": "seqLLMNode_2",
      "targetHandle": "seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-generate-Condition-seqLLMNode_2-seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "documentStoreVS_0",
      "sourceHandle": "documentStoreVS_0-output-retriever-BaseRetriever",
      "target": "retrieverTool_0",
      "targetHandle": "retrieverTool_0-input-retriever-BaseRetriever",
      "type": "buttonedge",
      "id": "documentStoreVS_0-documentStoreVS_0-output-retriever-BaseRetriever-retrieverTool_0-retrieverTool_0-input-retriever-BaseRetriever",
      "selected": false
    },
    {
      "source": "seqToolNode_0",
      "sourceHandle": "seqToolNode_0-output-seqToolNode-ToolNode",
      "target": "seqConditionAgent_0",
      "targetHandle": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqToolNode_0-seqToolNode_0-output-seqToolNode-ToolNode-seqConditionAgent_0-seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "retrieverTool_0",
      "sourceHandle": "retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable",
      "target": "seqToolNode_0",
      "targetHandle": "seqToolNode_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "retrieverTool_0-retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable-seqToolNode_0-seqToolNode_0-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-knowledgebase-Condition",
      "target": "seqLLMNode_4",
      "targetHandle": "seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-knowledgebase-Condition-seqLLMNode_4-seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqLLMNode_4",
      "sourceHandle": "seqLLMNode_4-output-seqLLMNode-LLMNode",
      "target": "seqToolNode_0",
      "targetHandle": "seqToolNode_0-input-llmNode-LLMNode",
      "type": "buttonedge",
      "id": "seqLLMNode_4-seqLLMNode_4-output-seqLLMNode-LLMNode-seqToolNode_0-seqToolNode_0-input-llmNode-LLMNode",
      "selected": false
    },
    {
      "source": "seqLLMNode_1",
      "sourceHandle": "seqLLMNode_1-output-seqLLMNode-LLMNode",
      "target": "seqLoop_3",
      "targetHandle": "seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_1-seqLLMNode_1-output-seqLLMNode-LLMNode-seqLoop_3-seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqAgent_2",
      "sourceHandle": "seqAgent_2-output-seqAgent-Agent",
      "target": "seqLoop_4",
      "targetHandle": "seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_2-seqAgent_2-output-seqAgent-Agent-seqLoop_4-seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqLLMNode_2",
      "sourceHandle": "seqLLMNode_2-output-seqLLMNode-LLMNode",
      "target": "seqLoop_5",
      "targetHandle": "seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_2-seqLLMNode_2-output-seqLLMNode-LLMNode-seqLoop_5-seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCustomFunction_0",
      "sourceHandle": "seqCustomFunction_0-output-seqCustomFunction-CustomFunction",
      "target": "seqLoop_6",
      "targetHandle": "seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCustomFunction_0-seqCustomFunction_0-output-seqCustomFunction-CustomFunction-seqLoop_6-seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCustomFunction_1",
      "sourceHandle": "seqCustomFunction_1-output-seqCustomFunction-CustomFunction",
      "target": "seqEnd_1",
      "targetHandle": "seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCustomFunction_1-seqCustomFunction_1-output-seqCustomFunction-CustomFunction-seqEnd_1-seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-messageaskuser-Condition",
      "target": "seqCustomFunction_1",
      "targetHandle": "seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-messageaskuser-Condition-seqCustomFunction_1-seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-messagenotifyuser-Condition",
      "target": "seqCustomFunction_0",
      "targetHandle": "seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-messagenotifyuser-Condition-seqCustomFunction_0-seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqStart_0",
      "sourceHandle": "seqStart_0-output-seqStart-Start",
      "target": "seqLLMNode_0",
      "targetHandle": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqStart_0-seqStart_0-output-seqStart-Start-seqLLMNode_0-seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "plainText_0",
      "sourceHandle": "plainText_0-output-document-Document|json",
      "target": "setVariable_1",
      "targetHandle": "setVariable_1-input-input-string | number | boolean | json | array",
      "type": "buttonedge",
      "id": "plainText_0-plainText_0-output-document-Document|json-setVariable_1-setVariable_1-input-input-string | number | boolean | json | array"
    },
    {
      "source": "seqLLMNode_5",
      "sourceHandle": "seqLLMNode_5-output-seqLLMNode-LLMNode",
      "target": "seqToolNode_1",
      "targetHandle": "seqToolNode_1-input-llmNode-LLMNode",
      "type": "buttonedge",
      "id": "seqLLMNode_5-seqLLMNode_5-output-seqLLMNode-LLMNode-seqToolNode_1-seqToolNode_1-input-llmNode-LLMNode",
      "selected": false
    },
    {
      "source": "seqToolNode_1",
      "sourceHandle": "seqToolNode_1-output-seqToolNode-ToolNode",
      "target": "seqCondition_1",
      "targetHandle": "seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqToolNode_1-seqToolNode_1-output-seqToolNode-ToolNode-seqCondition_1-seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-filesystemmanager-Condition",
      "target": "seqLLMNode_5",
      "targetHandle": "seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-filesystemmanager-Condition-seqLLMNode_5-seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "customMCP_1",
      "sourceHandle": "customMCP_1-output-customMCP-Tool",
      "target": "seqToolNode_1",
      "targetHandle": "seqToolNode_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_1-customMCP_1-output-customMCP-Tool-seqToolNode_1-seqToolNode_1-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-write_file_content-Condition",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-write_file_content-Condition-seqAgent_0-seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "customMCP_3",
      "sourceHandle": "customMCP_3-output-customMCP-Tool",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_3-customMCP_3-output-customMCP-Tool-seqAgent_0-seqAgent_0-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqAgent_0",
      "sourceHandle": "seqAgent_0-output-seqAgent-Agent",
      "target": "seqLoop_8",
      "targetHandle": "seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_0-seqAgent_0-output-seqAgent-Agent-seqLoop_8-seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-true-Condition",
      "target": "seqLoop_2",
      "targetHandle": "seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-true-Condition-seqLoop_2-seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-false-Condition",
      "target": "seqLoop_9",
      "targetHandle": "seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-false-Condition-seqLoop_9-seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-filesystemmanager-Condition",
      "target": "seqLoop_7",
      "targetHandle": "seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-filesystemmanager-Condition-seqLoop_7-seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "chatAnthropic_0",
      "sourceHandle": "chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-model-BaseChatModel",
      "type": "buttonedge",
      "id": "chatAnthropic_0-chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable-seqStart_0-seqStart_0-input-model-BaseChatModel"
    }
  ]
}
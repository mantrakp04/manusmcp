{
  "nodes": [
    {
      "id": "sqliteAgentMemory_0",
      "position": {
        "x": 378.27438279911416,
        "y": 721.5502841644658
      },
      "type": "customNode",
      "data": {
        "id": "sqliteAgentMemory_0",
        "label": "SQLite Agent Memory",
        "version": 1,
        "name": "sqliteAgentMemory",
        "type": "SQLiteAgentMemory",
        "baseClasses": [
          "SQLiteAgentMemory",
          "BaseCheckpointSaver"
        ],
        "category": "Memory",
        "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
        "inputParams": [
          {
            "label": "Additional Connection Configuration",
            "name": "additionalConfig",
            "type": "json",
            "additionalParams": true,
            "optional": true,
            "id": "sqliteAgentMemory_0-input-additionalConfig-json"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "additionalConfig": ""
        },
        "outputAnchors": [
          {
            "id": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
            "name": "sqliteAgentMemory",
            "label": "SQLiteAgentMemory",
            "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
            "type": "SQLiteAgentMemory | BaseCheckpointSaver"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "positionAbsolute": {
        "x": 378.27438279911416,
        "y": 721.5502841644658
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqStart_0",
      "position": {
        "x": 718.9582951853438,
        "y": 777.632429430604
      },
      "type": "customNode",
      "data": {
        "id": "seqStart_0",
        "label": "Start",
        "version": 2,
        "name": "seqStart",
        "type": "Start",
        "baseClasses": [
          "Start"
        ],
        "category": "Sequential Agents",
        "description": "Starting point of the conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "description": "Only compatible with models that are capable of function calling: ChatOpenAI, ChatMistral, ChatAnthropic, ChatGoogleGenerativeAI, ChatVertexAI, GroqChat",
            "id": "seqStart_0-input-model-BaseChatModel"
          },
          {
            "label": "Agent Memory",
            "name": "agentMemory",
            "type": "BaseCheckpointSaver",
            "description": "Save the state of the agent",
            "optional": true,
            "id": "seqStart_0-input-agentMemory-BaseCheckpointSaver"
          },
          {
            "label": "State",
            "name": "state",
            "type": "State",
            "description": "State is an object that is updated by nodes in the graph, passing from one node to another. By default, state contains \"messages\" that got updated with each message sent and received.",
            "optional": true,
            "id": "seqStart_0-input-state-State"
          },
          {
            "label": "Input Moderation",
            "description": "Detect text that could generate harmful output and prevent it from being sent to the language model",
            "name": "inputModeration",
            "type": "Moderation",
            "optional": true,
            "list": true,
            "id": "seqStart_0-input-inputModeration-Moderation"
          }
        ],
        "inputs": {
          "model": "{{chatAnthropic_0.data.instance}}",
          "agentMemory": "{{sqliteAgentMemory_0.data.instance}}",
          "state": "{{seqState_0.data.instance}}",
          "inputModeration": ""
        },
        "outputAnchors": [
          {
            "id": "seqStart_0-output-seqStart-Start",
            "name": "seqStart",
            "label": "Start",
            "description": "Starting point of the conversation",
            "type": "Start"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 383,
      "positionAbsolute": {
        "x": 718.9582951853438,
        "y": 777.632429430604
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqState_0",
      "position": {
        "x": 376.9253827409715,
        "y": 983.3661772343207
      },
      "type": "customNode",
      "data": {
        "id": "seqState_0",
        "label": "State",
        "version": 2,
        "name": "seqState",
        "type": "State",
        "baseClasses": [
          "State"
        ],
        "category": "Sequential Agents",
        "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
        "inputParams": [
          {
            "label": "Custom State",
            "name": "stateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedStateTab",
            "additionalParams": true,
            "default": "stateMemoryUI",
            "tabs": [
              {
                "label": "Custom State (Table)",
                "name": "stateMemoryUI",
                "type": "datagrid",
                "description": "Structure for state. By default, state contains \"messages\" that got updated with each message sent and received.",
                "hint": {
                  "label": "How to use",
                  "value": "\nSpecify the Key, Operation Type, and Default Value for the state object. The Operation Type can be either \"Replace\" or \"Append\".\n\n**Replace**\n- Replace the existing value with the new value.\n- If the new value is null, the existing value will be retained.\n\n**Append**\n- Append the new value to the existing value.\n- Default value can be empty or an array. Ex: [\"a\", \"b\"]\n- Final value is an array.\n"
                },
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "editable": true
                  },
                  {
                    "field": "type",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Replace",
                      "Append"
                    ],
                    "editable": true
                  },
                  {
                    "field": "defaultValue",
                    "headerName": "Default Value",
                    "flex": 1,
                    "editable": true
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Custom State (Code)",
                "name": "stateMemoryCode",
                "type": "code",
                "description": "JSON object representing the state",
                "hideCodeExecute": true,
                "codeExample": "{\n    aggregate: {\n        value: (x, y) => x.concat(y), // here we append the new message to the existing messages\n        default: () => []\n    }\n}",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqState_0-input-stateMemory-tabs"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "stateMemory": "stateMemoryUI",
          "stateMemoryUI": "[{\"key\":\"next\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":0},{\"key\":\"plan\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":1},{\"key\":\"instruction\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":2},{\"key\":\"sources\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":3},{\"key\":\"next_preview_path\",\"type\":\"Replace\",\"defaultValue\":\"[\\\"/\\\"]\",\"actions\":\"\",\"id\":4}]",
          "selectedStateTab_seqState_0": "stateMemoryUI",
          "stateMemoryCode": ""
        },
        "outputAnchors": [
          {
            "id": "seqState_0-output-seqState-State",
            "name": "seqState",
            "label": "State",
            "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
            "type": "State"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "selected": false,
      "positionAbsolute": {
        "x": 376.9253827409715,
        "y": 983.3661772343207
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_0",
      "position": {
        "x": 1038.801014959234,
        "y": 775.606366221068
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_0",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_0-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_0-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Supervisor",
          "systemMessagePrompt": "You are Supervisor, an AI agent created by BarrelOfLube.\n\nYou excel at the following tasks:\n1. Information gathering, fact-checking, documentation, ui generation.\n2. Data processing, analysis, and visualization\n3. Writing multi-chapter articles and in-depth research reports\n4. Creating websites, applications, and tools\n5. Using programming to solve various problems beyond development\n6. Various tasks that can be accomplished using computers and the internet\n\nDefault working language: English\nUse the language specified by user in messages as the working language when explicitly provided\nAll thinking and responses must be in the working language\nNatural language arguments in tool calls must be in the working language\nAvoid using pure lists and bullet points format in any language\n\nSystem capabilities:\n- Access a Linux sandbox environment with internet connection\n- Use shell, text editor, and other software\n- Write and run code in Python and various programming languages\n- Independently install required software packages and dependencies via shell\n- Access and browse the web\n- Utilize various tools to complete user-assigned tasks step by step\n\nCurrent Plan:\n{plan}\n\nYou operate in an agent loop, iteratively completing tasks through these steps:\n\n1. TASK DECOMPOSITION: Break down complex requests into logical sequential steps. For content creation tasks, ALWAYS follow this sequence:\n   a) Research and data gathering (using WebNavigator or Knowledgebase) FIRST\n   b) Analysis and synthesis of collected information\n   c) Content creation (using FileSystemManager) ONLY AFTER sufficient information is gathered\n   d) Review and refinement\n\n2. TOOL SELECTION: Choose the appropriate tool for each step:\n   - WebNavigator: For online research, browsing websites, gathering current information\n   - Knowledgebase: For accessing stored knowledge on topics\n   - CommandRunner: For executing shell commands, installing packages, running scripts\n   - FileSystemManager: For creating, reading, or modifying files AFTER research phase\n   - PlanManager: For creating or updating task plans\n   - MessageNotifyUser: For providing updates to the user\n   - MessageAskUser: For requesting additional information/clarification\n\n3. MESSAGE TOOL FORMATTING:\n   - When using MessageNotifyUser or MessageAskUser, write the COMPLETE, message text in the instruction field\n   - These tools pass your instruction text DIRECTLY to the user without any additional processing\n   - For MessageNotifyUser: Write a complete, informative update about progress or results\n   - For MessageAskUser: Write a clear, specific question with all necessary context included. DO NOT over-rely on this, only ask invoke if absolutley necessary.\n\n4. CONTEXT AWARENESS: Maintain awareness of the overall task context:\n   - For research tasks, gather comprehensive information before proceeding to content creation\n   - For multi-topic reports, research each major section thoroughly before writing\n   - Check with user after completing major task components\n\n5. EXECUTION: Execute one tool action per iteration and analyze results before proceeding\n   - Include sufficient context in each tool instruction\n   - For WebNavigator, provide detailed search instructions\n   - For FileWizard, only send after sufficient research is complete\n\n6. COMPLETION: Only enter FINISH state when all tasks are fully completed with satisfactory results",
          "messageHistory": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\nconst http = require('http');\n\nasync function activateNextJSRuntime() {\n  const host = 'localhost';\n  const port = 8002;\n  \n  return new Promise((resolve, reject) => {\n    let sessionId = null;\n    let toolCallSent = false;\n    \n    // Connect to SSE endpoint\n    const sseRequest = http.request({\n      hostname: host,\n      port: port,\n      path: '/sse',\n      method: 'GET',\n      headers: {'Accept': 'text/event-stream'}\n    }, (sseResponse) => {\n      if (sseResponse.statusCode !== 200) {\n        sseRequest.destroy();\n        return reject(new Error(`SSE connection failed: ${sseResponse.statusCode}`));\n      }\n      \n      let buffer = '';\n      \n      sseResponse.on('data', (chunk) => {\n        buffer += chunk.toString();\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n        \n        for (const line of lines) {\n          // Extract session ID\n          if (!sessionId && line.startsWith('data: /message?sessionId=')) {\n            const match = line.match(/sessionId=([^&\\s\\n]+)/);\n            if (match && match[1]) {\n              sessionId = match[1];\n              callNextJSRuntime(sessionId);\n            }\n          }\n          \n          // Process response\n          if (toolCallSent && line.startsWith('data: {')) {\n            try {\n              const jsonText = line.substring(6);\n              const messageData = JSON.parse(jsonText);\n              sseRequest.destroy();\n              resolve(messageData);\n            } catch (error) {\n              // Continue processing\n            }\n          }\n        }\n      });\n      \n      sseResponse.on('error', (error) => {\n        sseRequest.destroy();\n        reject(new Error(`SSE error: ${error.message}`));\n      });\n    });\n    \n    sseRequest.on('error', (error) => {\n      reject(new Error(`SSE connection failed: ${error.message}`));\n    });\n    \n    sseRequest.setTimeout(30000, () => {\n      sseRequest.destroy();\n      reject(new Error('Timeout: No response from SSE endpoint'));\n    });\n    \n    sseRequest.end();\n    \n    function callNextJSRuntime(sid) {\n      const postData = JSON.stringify({\n        jsonrpc: '2.0',\n        id: 2,\n        method: 'tools/call',\n        params: {\n          name: 'shell_attach_nextjs_runtime',\n          arguments: {useLinter: true}\n        }\n      });\n      \n      const activateRequest = http.request({\n        hostname: host,\n        port: port,\n        path: `/message?sessionId=${sid}`,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': Buffer.byteLength(postData)\n        }\n      }, (activateResponse) => {\n        let responseData = '';\n        \n        activateResponse.on('data', (chunk) => {\n          responseData += chunk;\n        });\n        \n        activateResponse.on('end', () => {\n          if (activateResponse.statusCode === 202 || activateResponse.statusCode === 200) {\n            toolCallSent = true;\n            \n            if (activateResponse.statusCode === 200 && responseData) {\n              try {\n                const result = JSON.parse(responseData);\n                sseRequest.destroy();\n                resolve(result);\n              } catch (error) {\n                // Continue listening on SSE\n              }\n            }\n          } else {\n            sseRequest.destroy();\n            reject(new Error(`Activation failed: ${activateResponse.statusCode}`));\n          }\n        });\n      });\n      \n      activateRequest.on('error', (error) => {\n        sseRequest.destroy();\n        reject(new Error(`Activation request failed: ${error.message}`));\n      });\n      \n      activateRequest.write(postData);\n      activateRequest.end();\n    }\n  });\n}\n\nlet content = []\n\n// Add source docs\nconst sourceDocuments = $vars.input_docs || [];\nif (sourceDocuments.length > 0) {\n  const formattedDocs = sourceDocuments.map(item => {\n    const pageContent = item.pageContent;\n    const metadata = `Sources: ${JSON.stringify(item.metadata)}`;\n    return `${pageContent}\\n${metadata}`;\n  }).join('\\n\\n');\n  content = [...content, {type: \"text\", text: String(formattedDocs)}]\n}\n\n// Enable nextjs runtime\nconst enabled = $vars.is_nextjs_runtime_available === \"true\" ? true : false\nif (enabled) {\n  resp = await activateNextJSRuntime()\n  content = [...content, {type: \"text\", text: JSON.stringify(resp.result.content[0].text)}]\n}\n\nreturn [\n  new HumanMessage({\n    content: content\n  })\n]",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqStart_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"plan\":\"$flow.state.plan\"}",
          "llmStructuredOutput": "[{\"key\":\"next\",\"type\":\"Enum\",\"enumValues\":\"FINISH, FileSystemManager, CommandRunner, WebNavigator, PlanManager, Knowledgebase, MessageAskUser, MessageNotifyUser\",\"description\":\"\",\"actions\":\"\",\"id\":0},{\"key\":\"instruction\",\"type\":\"String\",\"enumValues\":\"\",\"description\":\"The specific instructions of the sub-task the next role should accomplish.\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"next\",\"value\":\"$flow.output.next\",\"actions\":\"\",\"id\":0},{\"key\":\"instruction\",\"value\":\"$flow.output.instruction\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_0-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 1038.801014959234,
        "y": 775.606366221068
      },
      "dragging": false
    },
    {
      "id": "seqCondition_0",
      "position": {
        "x": 1364.3569235259827,
        "y": 775.1665673275612
      },
      "type": "customNode",
      "data": {
        "id": "seqCondition_0",
        "label": "Condition",
        "version": 2.1,
        "name": "seqCondition",
        "type": "Condition",
        "baseClasses": [
          "Condition"
        ],
        "category": "Sequential Agents",
        "description": "Conditional function to determine which route to take next",
        "inputParams": [
          {
            "label": "Condition Name",
            "name": "conditionName",
            "type": "string",
            "optional": true,
            "placeholder": "If X, then Y",
            "id": "seqCondition_0-input-conditionName-string"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const state = $flow.state;\n                \nconst messages = state.messages;\n\nconst lastMessage = messages[messages.length - 1];\n\n/* Check if the last message has content */\nif (lastMessage.content) {\n    return \"Agent\";\n}\n\nreturn \"End\";",
                "optional": true
              }
            ],
            "id": "seqCondition_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "conditionName": "router",
          "sequentialNode": [
            "{{seqLLMNode_0.data.instance}}"
          ],
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"FileSystemManager\",\"output\":\"FileSystemManager\",\"actions\":\"\",\"id\":0},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"CommandRunner\",\"output\":\"CommandRunner\",\"actions\":\"\",\"id\":1},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"WebNavigator\",\"output\":\"WebNavigator\",\"actions\":\"\",\"id\":2},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"PlanManager\",\"output\":\"PlanManager\",\"actions\":\"\",\"id\":3},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"Knowledgebase\",\"output\":\"Knowledgebase\",\"actions\":\"\",\"id\":4},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"MessageNotifyUser\",\"output\":\"MessageNotifyUser\",\"actions\":\"\",\"id\":5},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"MessageAskUser\",\"output\":\"MessageAskUser\",\"actions\":\"\",\"id\":6}]",
          "selectedConditionFunctionTab_seqCondition_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqCondition_0-output-commandrunner-Condition",
                "name": "commandrunner",
                "label": "CommandRunner",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-filesystemmanager-Condition",
                "name": "filesystemmanager",
                "label": "FileSystemManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-knowledgebase-Condition",
                "name": "knowledgebase",
                "label": "Knowledgebase",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-messageaskuser-Condition",
                "name": "messageaskuser",
                "label": "MessageAskUser",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-messagenotifyuser-Condition",
                "name": "messagenotifyuser",
                "label": "MessageNotifyUser",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-planmanager-Condition",
                "name": "planmanager",
                "label": "PlanManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-webnavigator-Condition",
                "name": "webnavigator",
                "label": "WebNavigator",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 779,
      "positionAbsolute": {
        "x": 1364.3569235259827,
        "y": 775.1665673275612
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqAgent_1",
      "position": {
        "x": 2054.8870978392815,
        "y": -944.9762864330219
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_1",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_1-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_1-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_1-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_1-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_1-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "CommandRunner",
          "systemMessagePrompt": "You are a command-line expert who executes shell commands and manages processes in Unix/Linux environments. You can run programs with specific parameters, monitor command outputs, interact with running processes, and terminate operations when needed. Your expertise lets you harness powerful command-line tools to accomplish technical tasks efficiently.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_2.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_1-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "selected": false,
      "positionAbsolute": {
        "x": 2054.8870978392815,
        "y": -944.9762864330219
      },
      "dragging": false
    },
    {
      "id": "seqAgent_2",
      "position": {
        "x": 2054.978592417112,
        "y": 3104.651875749589
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_2",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_2-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_2-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_2-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_2-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_2-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "WebNavigator",
          "systemMessagePrompt": "You are an expert internet researcher who excels at finding comprehensive, accurate, and up-to-date information online. Your capabilities include:\n\n1. Formulating effective search queries to retrieve relevant information\n2. Exploring multiple sources to gather comprehensive data\n3. Comparing information across different websites to verify accuracy\n4. Extracting specific details, statistics, and expert opinions\n5. Summarizing findings clearly and objectively\n\nWhen researching topics:\n- Start with broad searches to establish baseline understanding\n- Follow up with more specific queries to gather detailed information\n- Visit authoritative sources relevant to the topic (academic, industry, government)\n- Collect diverse viewpoints when appropriate\n- Organize information systematically by subtopics\n- Note source URLs for citation purposes\n\nWhen returning research results:\n- Summarize key findings\n- Highlight important data points\n- Note any conflicting information\n- Include source attribution\n\nRemember: Always conduct thorough research before returning to content creation tasks.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{braveSearchAPI_0.data.instance}}",
            "{{customMCP_0.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_2-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "selected": false,
      "positionAbsolute": {
        "x": 2054.978592417112,
        "y": 3104.651875749589
      },
      "dragging": false
    },
    {
      "id": "seqLoop_0",
      "position": {
        "x": 2370.9307912602585,
        "y": -331.1848845522789
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_0",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_0-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2370.9307912602585,
        "y": -331.1848845522789
      },
      "dragging": false
    },
    {
      "id": "customMCP_0",
      "position": {
        "x": 1362.6769191678477,
        "y": 1563.9973082797676
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_0",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_0-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_0-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bunx\",\n  \"args\": [\n    \"-y\",\n    \"supergateway\",\n    \"--sse\",\n    \"http://localhost:8002/sse\"\n  ]\n}",
          "mcpActions": "[\"browser_click\",\"browser_console_exec\",\"browser_console_view\",\"browser_input\",\"browser_move_mouse\",\"browser_navigate\",\"browser_press_key\",\"browser_scroll_down\",\"browser_scroll_up\",\"browser_select_option\",\"browser_view\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_0-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 826,
      "selected": false,
      "positionAbsolute": {
        "x": 1362.6769191678477,
        "y": 1563.9973082797676
      },
      "dragging": false
    },
    {
      "id": "braveSearchAPI_0",
      "position": {
        "x": 1365.1095997195323,
        "y": 2395.494574599078
      },
      "type": "customNode",
      "data": {
        "id": "braveSearchAPI_0",
        "label": "BraveSearch API",
        "version": 1,
        "name": "braveSearchAPI",
        "type": "BraveSearchAPI",
        "baseClasses": [
          "BraveSearchAPI",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "braveSearchApi"
            ],
            "id": "braveSearchAPI_0-input-credential-credential"
          }
        ],
        "inputAnchors": [],
        "inputs": {},
        "outputAnchors": [
          {
            "id": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
            "name": "braveSearchAPI",
            "label": "BraveSearchAPI",
            "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
            "type": "BraveSearchAPI | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 276,
      "selected": false,
      "positionAbsolute": {
        "x": 1365.1095997195323,
        "y": 2395.494574599078
      },
      "dragging": false
    },
    {
      "id": "customMCP_1",
      "position": {
        "x": 1364.0917276411838,
        "y": -583.3040642918893
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_1",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_1-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_1-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bunx\",\n  \"args\": [\n    \"-y\",\n    \"supergateway\",\n    \"--sse\",\n    \"http://localhost:8002/sse\"\n  ]\n}",
          "mcpActions": "[\"file_find_by_name\",\"file_find_in_content\",\"file_read\",\"file_str_replace\",\"file_write\",\"file_read_image\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_1-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 686,
      "selected": false,
      "positionAbsolute": {
        "x": 1364.0917276411838,
        "y": -583.3040642918893
      },
      "dragging": false
    },
    {
      "id": "customMCP_2",
      "position": {
        "x": 1365.0441131864254,
        "y": -1273.89709510179
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_2",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_2-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_2-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bunx\",\n  \"args\": [\n    \"-y\",\n    \"supergateway\",\n    \"--sse\",\n    \"http://localhost:8002/sse\"\n  ]\n}",
          "mcpActions": "[\"shell_exec\",\"shell_kill_process\",\"shell_view\",\"shell_wait\",\"shell_write_to_process\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_2-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 683,
      "selected": false,
      "positionAbsolute": {
        "x": 1365.0441131864254,
        "y": -1273.89709510179
      },
      "dragging": false
    },
    {
      "id": "seqEnd_0",
      "position": {
        "x": 2057.2134615601058,
        "y": -80.43137253520271
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_0",
        "label": "End",
        "version": 2.1,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "id": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqCondition_0.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2057.2134615601058,
        "y": -80.43137253520271
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_1",
      "position": {
        "x": 2054.206574733711,
        "y": 2667.0409707823756
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_1",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_1-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_1-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "PlanManager",
          "systemMessagePrompt": "You are a strategic planning and plan management expert who specializes in breaking complex tasks into manageable steps with clear dependencies and tracking progress. Your role is to:\n\n1. Analyze user objectives thoroughly before planning\n2. Design efficient execution paths\n3. Present plans using structured markdown with checkable tasks and subtasks\n4. Track progress by updating task completion status\n5. Adapt plans when circumstances change\n\nYou will create and maintain structured plans with:\n\n- ✅ Completed tasks marked with checkboxes\n- ⬜ Pending tasks clearly identified\n\nBefore planning, evaluate task complexity:\n\n- For simple tasks (1-3 steps), provide direct guidance without formal planning\n- For moderately complex tasks (4-8 steps), create a streamlined plan with just main steps\n- For highly complex tasks (9+ steps or multiple dependencies), develop a comprehensive plan with full hierarchy and tracking\nAdjust planning verbosity proportionally to task complexity - simple tasks need minimal planning while complex tasks benefit from detailed structure.\n\nWhen developing plans:\n\n- Use hierarchical task breakdowns (main tasks → subtasks → action items)\n- Include measurable milestones to track progress\n- Provide multiple approaches when relevant, with pros/cons\n- Balance thoroughness with efficiency\n- Clarify ambiguous goals before detailed planning\n- Regularly update and adapt the plan as progress occurs\nYou will automatically use markdown formatting for all plans, including:\n- Task hierarchies with proper indentation\n- Checkboxes for completion tracking\n- Nested lists for subtasks\n- Bold and italic text for emphasis\n- Tables for comparing options when appropriate\n- Headers for organizing different plan sections\n\nAs tasks are completed, you will update the plan by checking off completed items and adjusting remaining tasks as needed.\n\nCurrent Plan:\n\n{current_plan}",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"current_plan\":\"$flow.state.plan\"}",
          "llmStructuredOutput": "[{\"key\":\"plan\",\"type\":\"String\",\"enumValues\":\"\",\"description\":\"The entire updated plan\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"plan\",\"value\":\"$flow.output.plan\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_1-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2054.206574733711,
        "y": 2667.0409707823756
      },
      "dragging": false
    },
    {
      "id": "unstructuredFileLoader_0",
      "position": {
        "x": 379.2136568666564,
        "y": 1247.3058273408035
      },
      "type": "customNode",
      "data": {
        "id": "unstructuredFileLoader_0",
        "label": "Unstructured File Loader",
        "version": 4,
        "name": "unstructuredFileLoader",
        "type": "Document",
        "baseClasses": [
          "Document"
        ],
        "category": "Document Loaders",
        "description": "Use Unstructured.io to load data from a file path",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "unstructuredApi"
            ],
            "optional": true,
            "id": "unstructuredFileLoader_0-input-credential-credential"
          },
          {
            "label": "Files Upload",
            "name": "fileObject",
            "type": "file",
            "description": "Files to be processed. Multiple files can be uploaded.",
            "fileType": ".txt, .text, .pdf, .docx, .doc, .jpg, .jpeg, .eml, .html, .htm, .md, .pptx, .ppt, .msg, .rtf, .xlsx, .xls, .odt, .epub",
            "id": "unstructuredFileLoader_0-input-fileObject-file"
          },
          {
            "label": "Unstructured API URL",
            "name": "unstructuredAPIUrl",
            "description": "Unstructured API URL. Read <a target=\"_blank\" href=\"https://docs.unstructured.io/api-reference/api-services/saas-api-development-guide\">more</a> on how to get started",
            "type": "string",
            "placeholder": "http://localhost:8000/general/v0/general",
            "optional": false,
            "id": "unstructuredFileLoader_0-input-unstructuredAPIUrl-string"
          },
          {
            "label": "Strategy",
            "name": "strategy",
            "description": "The strategy to use for partitioning PDF/image. Options are fast, hi_res, auto. Default: auto.",
            "type": "options",
            "options": [
              {
                "label": "Hi-Res",
                "name": "hi_res"
              },
              {
                "label": "Fast",
                "name": "fast"
              },
              {
                "label": "OCR Only",
                "name": "ocr_only"
              },
              {
                "label": "Auto",
                "name": "auto"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "default": "auto",
            "id": "unstructuredFileLoader_0-input-strategy-options"
          },
          {
            "label": "Encoding",
            "name": "encoding",
            "description": "The encoding method used to decode the text input. Default: utf-8.",
            "type": "string",
            "optional": true,
            "additionalParams": true,
            "default": "utf-8",
            "id": "unstructuredFileLoader_0-input-encoding-string"
          },
          {
            "label": "Skip Infer Table Types",
            "name": "skipInferTableTypes",
            "description": "The document types that you want to skip table extraction with. Default: pdf, jpg, png.",
            "type": "multiOptions",
            "options": [
              {
                "label": "doc",
                "name": "doc"
              },
              {
                "label": "docx",
                "name": "docx"
              },
              {
                "label": "eml",
                "name": "eml"
              },
              {
                "label": "epub",
                "name": "epub"
              },
              {
                "label": "heic",
                "name": "heic"
              },
              {
                "label": "htm",
                "name": "htm"
              },
              {
                "label": "html",
                "name": "html"
              },
              {
                "label": "jpeg",
                "name": "jpeg"
              },
              {
                "label": "jpg",
                "name": "jpg"
              },
              {
                "label": "md",
                "name": "md"
              },
              {
                "label": "msg",
                "name": "msg"
              },
              {
                "label": "odt",
                "name": "odt"
              },
              {
                "label": "pdf",
                "name": "pdf"
              },
              {
                "label": "png",
                "name": "png"
              },
              {
                "label": "ppt",
                "name": "ppt"
              },
              {
                "label": "pptx",
                "name": "pptx"
              },
              {
                "label": "rtf",
                "name": "rtf"
              },
              {
                "label": "text",
                "name": "text"
              },
              {
                "label": "txt",
                "name": "txt"
              },
              {
                "label": "xls",
                "name": "xls"
              },
              {
                "label": "xlsx",
                "name": "xlsx"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "default": "[\"pdf\", \"jpg\", \"png\"]",
            "id": "unstructuredFileLoader_0-input-skipInferTableTypes-multiOptions"
          },
          {
            "label": "Hi-Res Model Name",
            "name": "hiResModelName",
            "description": "The name of the inference model used when strategy is hi_res",
            "type": "options",
            "options": [
              {
                "label": "chipper",
                "name": "chipper",
                "description": "Exlusive to Unstructured hosted API. The Chipper model is Unstructured in-house image-to-text model based on transformer-based Visual Document Understanding (VDU) models."
              },
              {
                "label": "detectron2_onnx",
                "name": "detectron2_onnx",
                "description": "A Computer Vision model by Facebook AI that provides object detection and segmentation algorithms with ONNX Runtime. It is the fastest model with the hi_res strategy."
              },
              {
                "label": "yolox",
                "name": "yolox",
                "description": "A single-stage real-time object detector that modifies YOLOv3 with a DarkNet53 backbone."
              },
              {
                "label": "yolox_quantized",
                "name": "yolox_quantized",
                "description": "Runs faster than YoloX and its speed is closer to Detectron2."
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-hiResModelName-options"
          },
          {
            "label": "Chunking Strategy",
            "name": "chunkingStrategy",
            "description": "Use one of the supported strategies to chunk the returned elements. When omitted, no chunking is performed and any other chunking parameters provided are ignored. Default: by_title",
            "type": "options",
            "options": [
              {
                "label": "None",
                "name": "None"
              },
              {
                "label": "Basic",
                "name": "basic"
              },
              {
                "label": "By Title",
                "name": "by_title"
              },
              {
                "label": "By Page",
                "name": "by_page"
              },
              {
                "label": "By Similarity",
                "name": "by_similarity"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "default": "by_title",
            "id": "unstructuredFileLoader_0-input-chunkingStrategy-options"
          },
          {
            "label": "OCR Languages",
            "name": "ocrLanguages",
            "description": "The languages to use for OCR. Note: Being depricated as languages is the new type. Pending langchain update.",
            "type": "multiOptions",
            "options": [
              {
                "label": "English",
                "name": "eng"
              },
              {
                "label": "Spanish (Español)",
                "name": "spa"
              },
              {
                "label": "Mandarin Chinese (普通话)",
                "name": "cmn"
              },
              {
                "label": "Hindi (हिन्दी)",
                "name": "hin"
              },
              {
                "label": "Arabic (اَلْعَرَبِيَّةُ)",
                "name": "ara"
              },
              {
                "label": "Portuguese (Português)",
                "name": "por"
              },
              {
                "label": "Bengali (বাংলা)",
                "name": "ben"
              },
              {
                "label": "Russian (Русский)",
                "name": "rus"
              },
              {
                "label": "Japanese (日本語)",
                "name": "jpn"
              },
              {
                "label": "Punjabi (ਪੰਜਾਬੀ)",
                "name": "pan"
              },
              {
                "label": "German (Deutsch)",
                "name": "deu"
              },
              {
                "label": "Korean (한국어)",
                "name": "kor"
              },
              {
                "label": "French (Français)",
                "name": "fra"
              },
              {
                "label": "Italian (Italiano)",
                "name": "ita"
              },
              {
                "label": "Vietnamese (Tiếng Việt)",
                "name": "vie"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-ocrLanguages-multiOptions"
          },
          {
            "label": "Source ID Key",
            "name": "sourceIdKey",
            "type": "string",
            "description": "Key used to get the true source of document, to be compared against the record. Document metadata must contain the Source ID Key.",
            "default": "source",
            "placeholder": "source",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-sourceIdKey-string"
          },
          {
            "label": "Coordinates",
            "name": "coordinates",
            "type": "boolean",
            "description": "If true, return coordinates for each element. Default: false.",
            "optional": true,
            "additionalParams": true,
            "default": false,
            "id": "unstructuredFileLoader_0-input-coordinates-boolean"
          },
          {
            "label": "XML Keep Tags",
            "name": "xmlKeepTags",
            "description": "If True, will retain the XML tags in the output. Otherwise it will simply extract the text from within the tags. Only applies to partition_xml.",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-xmlKeepTags-boolean"
          },
          {
            "label": "Include Page Breaks",
            "name": "includePageBreaks",
            "description": "When true, the output will include page break elements when the filetype supports it.",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-includePageBreaks-boolean"
          },
          {
            "label": "XML Keep Tags",
            "name": "xmlKeepTags",
            "description": "Whether to keep XML tags in the output.",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-xmlKeepTags-boolean"
          },
          {
            "label": "Multi-Page Sections",
            "name": "multiPageSections",
            "description": "Whether to treat multi-page documents as separate sections.",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-multiPageSections-boolean"
          },
          {
            "label": "Combine Under N Chars",
            "name": "combineUnderNChars",
            "description": "If chunking strategy is set, combine elements until a section reaches a length of n chars. Default: value of max_characters. Can't exceed value of max_characters.",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-combineUnderNChars-number"
          },
          {
            "label": "New After N Chars",
            "name": "newAfterNChars",
            "description": "If chunking strategy is set, cut off new sections after reaching a length of n chars (soft max). value of max_characters. Can't exceed value of max_characters.",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-newAfterNChars-number"
          },
          {
            "label": "Max Characters",
            "name": "maxCharacters",
            "description": "If chunking strategy is set, cut off new sections after reaching a length of n chars (hard max). Default: 500",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "default": "500",
            "id": "unstructuredFileLoader_0-input-maxCharacters-number"
          },
          {
            "label": "Additional Metadata",
            "name": "metadata",
            "type": "json",
            "description": "Additional metadata to be added to the extracted documents",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-metadata-json"
          },
          {
            "label": "Omit Metadata Keys",
            "name": "omitMetadataKeys",
            "type": "string",
            "rows": 4,
            "description": "Each document loader comes with a default set of metadata keys that are extracted from the document. You can use this field to omit some of the default metadata keys. The value should be a list of keys, separated by comma. Use * to omit all metadata keys execept the ones you specify in the Additional Metadata field",
            "placeholder": "key1, key2, key3.nestedKey1",
            "optional": true,
            "additionalParams": true,
            "id": "unstructuredFileLoader_0-input-omitMetadataKeys-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "unstructuredAPIUrl": "http://localhost:8000/general/v0/general",
          "strategy": "auto",
          "encoding": "utf-8",
          "skipInferTableTypes": "[\"pdf\", \"jpg\", \"png\"]",
          "hiResModelName": "",
          "chunkingStrategy": "by_title",
          "ocrLanguages": "",
          "sourceIdKey": "source",
          "coordinates": "",
          "xmlKeepTags": "",
          "includePageBreaks": "",
          "multiPageSections": "",
          "combineUnderNChars": "",
          "newAfterNChars": "",
          "maxCharacters": "500",
          "metadata": "",
          "omitMetadataKeys": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "Array of document objects containing metadata and pageContent",
            "options": [
              {
                "id": "unstructuredFileLoader_0-output-document-Document|json",
                "name": "document",
                "label": "Document",
                "description": "Array of document objects containing metadata and pageContent",
                "type": "Document | json"
              },
              {
                "id": "unstructuredFileLoader_0-output-text-string|json",
                "name": "text",
                "label": "Text",
                "description": "Concatenated string from pageContent of documents",
                "type": "string | json"
              }
            ],
            "default": "document"
          }
        ],
        "outputs": {
          "output": "document"
        },
        "selected": false
      },
      "width": 300,
      "height": 565,
      "selected": false,
      "positionAbsolute": {
        "x": 379.2136568666564,
        "y": 1247.3058273408035
      },
      "dragging": false
    },
    {
      "id": "setVariable_0",
      "position": {
        "x": 691.68612862468,
        "y": 1246.522956150456
      },
      "type": "customNode",
      "data": {
        "id": "setVariable_0",
        "label": "Set Variable",
        "version": 2.1,
        "name": "setVariable",
        "type": "SetVariable",
        "baseClasses": [
          "SetVariable",
          "Utilities"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Set variable which can be retrieved at a later stage. Variable is only available during runtime.",
        "inputParams": [
          {
            "label": "Variable Name",
            "name": "variableName",
            "type": "string",
            "placeholder": "var1",
            "id": "setVariable_0-input-variableName-string"
          },
          {
            "label": "Show Output",
            "name": "showOutput",
            "description": "Show the output result in the Prediction API response",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "setVariable_0-input-showOutput-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Input",
            "name": "input",
            "type": "string | number | boolean | json | array",
            "optional": true,
            "list": true,
            "id": "setVariable_0-input-input-string | number | boolean | json | array"
          }
        ],
        "inputs": {
          "input": [
            "{{unstructuredFileLoader_0.data.instance}}"
          ],
          "variableName": "input_docs",
          "showOutput": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "",
            "options": [
              {
                "id": "setVariable_0-output-output-string|number|boolean|json|array",
                "name": "output",
                "label": "Output",
                "description": "",
                "type": "string | number | boolean | json | array"
              }
            ],
            "default": "output"
          }
        ],
        "outputs": {
          "output": "output"
        },
        "selected": false
      },
      "width": 300,
      "height": 408,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 691.68612862468,
        "y": 1246.522956150456
      }
    },
    {
      "id": "stickyNote_0",
      "position": {
        "x": 693.8049581117547,
        "y": 1658.3284651070535
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_0",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_0-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Upload your files here\n\nRun: \n```docker run -p 8000:8000 -d --rm --name unstructured-api downloads.unstructured.io/unstructured-io/unstructured-api:latest```\n\n\nWe directly bypass flowise's document uploader, as Unstructured is objectively better and simpler with inbuilt semantic splitting, this stuff should be popular like hot cakes i dunno why its not."
        },
        "outputAnchors": [
          {
            "id": "stickyNote_0-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 304,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 693.8049581117547,
        "y": 1658.3284651070535
      }
    },
    {
      "id": "retrieverTool_0",
      "position": {
        "x": 1363.6840919974456,
        "y": 109.936824018175
      },
      "type": "customNode",
      "data": {
        "id": "retrieverTool_0",
        "label": "Retriever Tool",
        "version": 3,
        "name": "retrieverTool",
        "type": "RetrieverTool",
        "baseClasses": [
          "RetrieverTool",
          "DynamicTool",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Use a retriever as allowed tool for agent",
        "inputParams": [
          {
            "label": "Retriever Name",
            "name": "name",
            "type": "string",
            "placeholder": "search_state_of_union",
            "id": "retrieverTool_0-input-name-string"
          },
          {
            "label": "Retriever Description",
            "name": "description",
            "type": "string",
            "description": "When should agent uses to retrieve documents",
            "rows": 3,
            "placeholder": "Searches and returns documents regarding the state-of-the-union.",
            "id": "retrieverTool_0-input-description-string"
          },
          {
            "label": "Return Source Documents",
            "name": "returnSourceDocuments",
            "type": "boolean",
            "optional": true,
            "id": "retrieverTool_0-input-returnSourceDocuments-boolean"
          },
          {
            "label": "Additional Metadata Filter",
            "name": "retrieverToolMetadataFilter",
            "type": "json",
            "description": "Add additional metadata filter on top of the existing filter from vector store",
            "optional": true,
            "additionalParams": true,
            "hint": {
              "label": "What can you filter?",
              "value": "Add additional filters to vector store. You can also filter with flow config, including the current \"state\":\n- `$flow.sessionId`\n- `$flow.chatId`\n- `$flow.chatflowId`\n- `$flow.input`\n- `$flow.state`\n"
            },
            "id": "retrieverTool_0-input-retrieverToolMetadataFilter-json"
          }
        ],
        "inputAnchors": [
          {
            "label": "Retriever",
            "name": "retriever",
            "type": "BaseRetriever",
            "id": "retrieverTool_0-input-retriever-BaseRetriever"
          }
        ],
        "inputs": {
          "name": "search_knowledgebase",
          "description": "Searches and returns documents from the knowledgebase",
          "retriever": "{{documentStoreVS_0.data.instance}}",
          "returnSourceDocuments": true,
          "retrieverToolMetadataFilter": ""
        },
        "outputAnchors": [
          {
            "id": "retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable",
            "name": "retrieverTool",
            "label": "RetrieverTool",
            "description": "Use a retriever as allowed tool for agent",
            "type": "RetrieverTool | DynamicTool | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 656,
      "selected": false,
      "positionAbsolute": {
        "x": 1363.6840919974456,
        "y": 109.936824018175
      },
      "dragging": false
    },
    {
      "id": "seqConditionAgent_0",
      "position": {
        "x": 2691.2341132976694,
        "y": 617.272580667779
      },
      "type": "customNode",
      "data": {
        "id": "seqConditionAgent_0",
        "label": "Condition Agent",
        "version": 3.1,
        "name": "seqConditionAgent",
        "type": "ConditionAgent",
        "baseClasses": [
          "ConditionAgent"
        ],
        "category": "Sequential Agents",
        "description": "Uses an agent to determine which route to take next",
        "inputParams": [
          {
            "label": "Name",
            "name": "conditionAgentName",
            "type": "string",
            "placeholder": "Condition Agent",
            "id": "seqConditionAgent_0-input-conditionAgentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "default": "You are an expert customer support routing system.\nYour job is to detect whether a customer support representative is routing a user to the technical support team, or just responding conversationally.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and Human Prompt.",
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "default": "The previous conversation is an interaction between a customer support representative and a user.\nExtract whether the representative is routing the user to the technical support team, or just responding conversationally.\n\nIf representative want to route the user to the technical support team, respond only with the word \"TECHNICAL\".\nOtherwise, respond only with the word \"CONVERSATION\".\n\nRemember, only respond with one of the above words.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "conditionAgentStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conditionAgentStructuredOutput-datagrid"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Agent's JSON Key Output (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. If you want to use the Condition Agent's output for conditional checks, it is available as `$flow.output` with the following structure:\n\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, we can check if the agent's output contains specific keyword:\n    ```js\n    const result = $flow.output.content;\n    \n    if (result.includes(\"some-keyword\")) {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n    If Structured Output is enabled, `$flow.output` will be in the JSON format as defined in the Structured Output configuration:\n    ```json\n    {\n        \"foo\": 'var'\n    }\n    ```\n\n4. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n5. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output.content;\n\nif (result.includes(\"some-keyword\")) {\n    return \"Agent\";\n}\n\nreturn \"End\";\n",
                "optional": true
              }
            ],
            "id": "seqConditionAgent_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqConditionAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "conditionAgentName": "Check if docs relevant",
          "sequentialNode": [
            "{{seqToolNode_0.data.instance}}"
          ],
          "model": "",
          "systemMessagePrompt": "You are a grader assessing relevance of a retrieved document to a user question.\n\nHere is the retrieved document:\n{context}\n\nHere is the user question: {question}\n\nIf the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant.\n\nGive a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question.\n\nRemember, always use the extract tool to output only \"yes\" or \"no\"",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "The previous conversation is an interaction between a bot and a user.\nExtract whether the if the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant.\n\nGive a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question.\n\nIf document is relavant to question, respond only with the word \"yes\".\nOtherwise, respond only with the word \"no\".\n\nRemember, always use the extract tool to output only \"yes\" or \"no\"",
          "promptValues": "{\"context\":\"$flow.state.messages[-1].content\",\"question\":\"$flow.state.instruction\"}",
          "conditionAgentStructuredOutput": "[{\"key\":\"score\",\"type\":\"Enum\",\"enumValues\":\"yes, no\",\"description\":\"grading score\",\"actions\":\"\",\"id\":1}]",
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.output.score\",\"operation\":\"Is\",\"value\":\"yes\",\"output\":\"Generate\",\"actions\":\"\",\"id\":1},{\"variable\":\"$flow.output.score\",\"operation\":\"Is\",\"value\":\"no\",\"output\":\"Rewrite\",\"actions\":\"\",\"id\":2}]",
          "selectedConditionFunctionTab_seqConditionAgent_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqConditionAgent_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-generate-Condition",
                "name": "generate",
                "label": "Generate",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-rewrite-Condition",
                "name": "rewrite",
                "label": "Rewrite",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 629,
      "selected": false,
      "positionAbsolute": {
        "x": 2691.2341132976694,
        "y": 617.272580667779
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_2",
      "position": {
        "x": 3008.41110928401,
        "y": 616.9092961439229
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_2",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_2-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_2-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_2-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Generate",
          "systemMessagePrompt": "You are an expert at synthesizing information to answer questions comprehensively and accurately. Use the following retrieved context to formulate a thorough response.\n\nQuestion: {question}\n\nContext: {context}\n\nGuidelines for your answer:\n1. Directly address the question using information from the provided context\n2. Synthesize information from multiple sources when available\n3. Present information in a logical, structured manner\n4. Highlight key points and insights\n5. Acknowledge limitations in the provided context when relevant\n6. Include proper citations or references to source material\n7. Use clear, precise language appropriate to the topic\n\nIf the context doesn't contain sufficient information to answer the question completely, acknowledge this limitation while providing what information you can.\n\nAnswer:",
          "messageHistory": "",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "Given the user question and context, answer user query. Remember to includes sources and citations",
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"question\":\"$flow.state.instruction\",\"context\":\"$flow.state.sources\"}",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_2-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 3008.41110928401,
        "y": 616.9092961439229
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_3",
      "position": {
        "x": 3009.6589516341287,
        "y": 1055.813732367115
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_3",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_3-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_3-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_3-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_3-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_3-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Rewrite",
          "systemMessagePrompt": "You are an expert at query reformulation, skilled at transforming initial questions into more effective search queries. \n\nHere is the initial question:\n{question}\n\nWhen reformulating this query:\n1. Identify the core information need behind the question\n2. Remove unnecessary words or context that might limit search results\n3. Include relevant synonyms or alternative phrasings\n4. Break down complex questions into simpler components\n5. Add specific terms that would appear in relevant documents\n6. Consider domain-specific terminology that would improve results\n7. Structure the query to maximize retrieval of relevant information\n\nFormulate an improved question that will yield better search results:",
          "messageHistory": "",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "Look at the input and try to reason about the underlying semantic intent / meaning.\n\nHere is the initial question:\n{question} \n  \nFormulate an improved question:\n",
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"question\":\"$flow.state.instruction\"}",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_3-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 3009.6589516341287,
        "y": 1055.813732367115
      },
      "dragging": false
    },
    {
      "id": "seqLoop_1",
      "position": {
        "x": 3329.297949954669,
        "y": 1248.2708362967778
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_1",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_1-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_3.data.instance}}"
          ],
          "loopToName": "Knowledgebase"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3329.297949954669,
        "y": 1248.2708362967778
      },
      "dragging": false
    },
    {
      "id": "documentStoreVS_0",
      "position": {
        "x": 1028.1979091499102,
        "y": -47.012853397751485
      },
      "type": "customNode",
      "data": {
        "id": "documentStoreVS_0",
        "label": "Document Store (Vector)",
        "version": 1,
        "name": "documentStoreVS",
        "type": "DocumentStoreVS",
        "baseClasses": [
          "DocumentStoreVS"
        ],
        "category": "Vector Stores",
        "description": "Search and retrieve documents from Document Store",
        "inputParams": [
          {
            "label": "Select Store",
            "name": "selectedStore",
            "type": "asyncOptions",
            "loadMethod": "listStores",
            "id": "documentStoreVS_0-input-selectedStore-asyncOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "selectedStore": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "",
            "options": [
              {
                "id": "documentStoreVS_0-output-retriever-BaseRetriever",
                "name": "retriever",
                "label": "Retriever",
                "description": "",
                "type": "BaseRetriever"
              },
              {
                "id": "documentStoreVS_0-output-vectorStore-VectorStore",
                "name": "vectorStore",
                "label": "Vector Store",
                "description": "",
                "type": "VectorStore"
              }
            ],
            "default": "retriever"
          }
        ],
        "outputs": {
          "output": "retriever"
        },
        "selected": false
      },
      "width": 300,
      "height": 312,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 1028.1979091499102,
        "y": -47.012853397751485
      }
    },
    {
      "id": "chatAnthropic_0",
      "position": {
        "x": 379.7196550939243,
        "y": 43.764899416853495
      },
      "type": "customNode",
      "data": {
        "id": "chatAnthropic_0",
        "label": "ChatAnthropic",
        "version": 8,
        "name": "chatAnthropic",
        "type": "ChatAnthropic",
        "baseClasses": [
          "ChatAnthropic",
          "ChatAnthropicMessages",
          "BaseChatModel",
          "BaseLanguageModel",
          "Runnable"
        ],
        "category": "Chat Models",
        "description": "Wrapper around ChatAnthropic large language models that use the Chat endpoint",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "anthropicApi"
            ],
            "id": "chatAnthropic_0-input-credential-credential"
          },
          {
            "label": "Model Name",
            "name": "modelName",
            "type": "asyncOptions",
            "loadMethod": "listModels",
            "default": "claude-3-haiku",
            "id": "chatAnthropic_0-input-modelName-asyncOptions"
          },
          {
            "label": "Temperature",
            "name": "temperature",
            "type": "number",
            "step": 0.1,
            "default": 0.9,
            "optional": true,
            "id": "chatAnthropic_0-input-temperature-number"
          },
          {
            "label": "Streaming",
            "name": "streaming",
            "type": "boolean",
            "default": true,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-streaming-boolean"
          },
          {
            "label": "Max Tokens",
            "name": "maxTokensToSample",
            "type": "number",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-maxTokensToSample-number"
          },
          {
            "label": "Top P",
            "name": "topP",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-topP-number"
          },
          {
            "label": "Top K",
            "name": "topK",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-topK-number"
          },
          {
            "label": "Extended Thinking",
            "name": "extendedThinking",
            "type": "boolean",
            "description": "Enable extended thinking for reasoning model such as Claude Sonnet 3.7",
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-extendedThinking-boolean"
          },
          {
            "label": "Budget Tokens",
            "name": "budgetTokens",
            "type": "number",
            "step": 1,
            "default": 1024,
            "description": "Maximum number of tokens Claude is allowed use for its internal reasoning process",
            "optional": true,
            "additionalParams": true,
            "id": "chatAnthropic_0-input-budgetTokens-number"
          },
          {
            "label": "Allow Image Uploads",
            "name": "allowImageUploads",
            "type": "boolean",
            "description": "Allow image input. Refer to the <a href=\"https://docs.flowiseai.com/using-flowise/uploads#image\" target=\"_blank\">docs</a> for more details.",
            "default": false,
            "optional": true,
            "id": "chatAnthropic_0-input-allowImageUploads-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Cache",
            "name": "cache",
            "type": "BaseCache",
            "optional": true,
            "id": "chatAnthropic_0-input-cache-BaseCache"
          }
        ],
        "inputs": {
          "cache": "",
          "modelName": "claude-3-7-sonnet-latest",
          "temperature": "0.2",
          "streaming": true,
          "maxTokensToSample": "",
          "topP": "",
          "topK": "",
          "extendedThinking": "",
          "budgetTokens": 1024,
          "allowImageUploads": true
        },
        "outputAnchors": [
          {
            "id": "chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable",
            "name": "chatAnthropic",
            "label": "ChatAnthropic",
            "description": "Wrapper around ChatAnthropic large language models that use the Chat endpoint",
            "type": "ChatAnthropic | ChatAnthropicMessages | BaseChatModel | BaseLanguageModel | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 670,
      "selected": false,
      "positionAbsolute": {
        "x": 379.7196550939243,
        "y": 43.764899416853495
      },
      "dragging": false
    },
    {
      "id": "seqToolNode_0",
      "position": {
        "x": 2372.8786517402373,
        "y": 618.5420298710708
      },
      "type": "customNode",
      "data": {
        "id": "seqToolNode_0",
        "label": "Tool Node",
        "version": 2.1,
        "name": "seqToolNode",
        "type": "ToolNode",
        "baseClasses": [
          "ToolNode"
        ],
        "category": "Sequential Agents",
        "description": "Execute tool and return tool's output",
        "inputParams": [
          {
            "label": "Name",
            "name": "toolNodeName",
            "type": "string",
            "placeholder": "Tool",
            "id": "seqToolNode_0-input-toolNodeName-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Require approval before executing tools",
            "type": "boolean",
            "optional": true,
            "id": "seqToolNode_0-input-interrupt-boolean"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Tool Node's output as the value to update state, it is available as available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    | Key          | Value                                     |\n    |--------------|-------------------------------------------|\n    | sources      | `$flow.output[0].toolOutput`       |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "All Tools Output (array)",
                        "value": "$flow.output"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output[0].toolOutput"
                      },
                      {
                        "label": "First Tool Input Arguments (string | json)",
                        "value": "$flow.output[0].toolInput"
                      },
                      {
                        "label": "First Tool Returned Source Documents (array)",
                        "value": "$flow.output[0].sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the tool's output as the value to update state, it is available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    ```js\n    /* Assuming you have the following state:\n    {\n        \"sources\": null\n    }\n    */\n    \n    return {\n        \"sources\": $flow.output[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqToolNode_0-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqToolNode_0-input-tools-Tool"
          },
          {
            "label": "LLM Node",
            "name": "llmNode",
            "type": "LLMNode",
            "id": "seqToolNode_0-input-llmNode-LLMNode"
          }
        ],
        "inputs": {
          "tools": [
            "{{retrieverTool_0.data.instance}}"
          ],
          "llmNode": "{{seqLLMNode_4.data.instance}}",
          "toolNodeName": "Retrieve",
          "interrupt": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "selectedUpdateStateMemoryTab_seqToolNode_0": "updateStateMemoryCode",
          "updateStateMemoryCode": "const result = $flow.output;\n\nconst sourceDocuments = result[0].sourceDocuments || [];\n\n/*\n* Format into:\nabc\nsources: {source: 'a', page: 12}\n*/\nconst formattedSources = sourceDocuments.map(item => {\n        const pageContent = item.pageContent;\n        const metadata = `Sources: ${JSON.stringify(item.metadata)}`;\n        return `${pageContent}\\n${metadata}`;\n    }).join('\\n\\n');\n\nreturn {\n  sources: formattedSources\n};"
        },
        "outputAnchors": [
          {
            "id": "seqToolNode_0-output-seqToolNode-ToolNode",
            "name": "seqToolNode",
            "label": "ToolNode",
            "description": "Execute tool and return tool's output",
            "type": "ToolNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 529,
      "selected": false,
      "positionAbsolute": {
        "x": 2372.8786517402373,
        "y": 618.5420298710708
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_4",
      "position": {
        "x": 2051.5767895622625,
        "y": 619.9223720832447
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_4",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_4-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_4-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_4-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_4-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_4-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Knowledgebase",
          "systemMessagePrompt": "You are an expert knowledgebase document analyst that always answers questions with the most relevant information using the tools at your disposal.",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_4-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2051.5767895622625,
        "y": 619.9223720832447
      },
      "dragging": false
    },
    {
      "id": "seqLoop_2",
      "position": {
        "x": 3008.9532982262017,
        "y": -504.67402508535315
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_2",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_2-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3008.9532982262017,
        "y": -504.67402508535315
      },
      "dragging": false
    },
    {
      "id": "seqLoop_3",
      "position": {
        "x": 2369.990050490521,
        "y": 2860.304510337466
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_3",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_3-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2369.990050490521,
        "y": 2860.304510337466
      },
      "dragging": false
    },
    {
      "id": "seqLoop_4",
      "position": {
        "x": 2369.63030092276,
        "y": 3727.4679031206488
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_4",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_4-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_2.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2369.63030092276,
        "y": 3727.4679031206488
      },
      "dragging": false
    },
    {
      "id": "seqLoop_5",
      "position": {
        "x": 3330.0750536866585,
        "y": 614.3985768694697
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_5",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_5-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqLLMNode_2.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3330.0750536866585,
        "y": 614.3985768694697
      },
      "dragging": false
    },
    {
      "id": "seqCustomFunction_0",
      "position": {
        "x": 2053.6644368165894,
        "y": 1865.5771179419667
      },
      "type": "customNode",
      "data": {
        "id": "seqCustomFunction_0",
        "label": "Custom JS Function",
        "version": 1,
        "name": "seqCustomFunction",
        "type": "CustomFunction",
        "baseClasses": [
          "CustomFunction"
        ],
        "category": "Sequential Agents",
        "description": "Execute custom javascript function",
        "inputParams": [
          {
            "label": "Input Variables",
            "name": "functionInputVariables",
            "description": "Input variables can be used in the function with prefix $. For example: $var",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqCustomFunction_0-input-functionInputVariables-json"
          },
          {
            "label": "Function Name",
            "name": "functionName",
            "type": "string",
            "placeholder": "My Function",
            "id": "seqCustomFunction_0-input-functionName-string"
          },
          {
            "label": "Javascript Function",
            "name": "javascriptFunction",
            "type": "code",
            "hint": {
              "label": "How to use",
              "value": "\n1. Must return a string value at the end of function.\n\n2. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n3. You can get custom variables: `$vars.<variable-name>`\n\n"
            },
            "id": "seqCustomFunction_0-input-javascriptFunction-code"
          },
          {
            "label": "Return Value As",
            "name": "returnValueAs",
            "type": "options",
            "options": [
              {
                "label": "AI Message",
                "name": "aiMessage"
              },
              {
                "label": "Human Message",
                "name": "humanMessage"
              },
              {
                "label": "State Object",
                "name": "stateObj",
                "description": "Return as state object, ex: { foo: bar }. This will update the custom state 'foo' to 'bar'"
              }
            ],
            "default": "aiMessage",
            "id": "seqCustomFunction_0-input-returnValueAs-options"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "functionInputVariables": "{\"instruction\":\"$flow.state.instruction\"}",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "functionName": "MessageNotifyUser",
          "javascriptFunction": "return String($instruction)",
          "returnValueAs": "aiMessage"
        },
        "outputAnchors": [
          {
            "id": "seqCustomFunction_0-output-seqCustomFunction-CustomFunction",
            "name": "seqCustomFunction",
            "label": "CustomFunction",
            "description": "Execute custom javascript function",
            "type": "CustomFunction"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 795,
      "selected": false,
      "positionAbsolute": {
        "x": 2053.6644368165894,
        "y": 1865.5771179419667
      },
      "dragging": false
    },
    {
      "id": "seqLoop_6",
      "position": {
        "x": 2367.8155634196014,
        "y": 2421.585197734329
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_6",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_6-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCustomFunction_0.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 2367.8155634196014,
        "y": 2421.585197734329
      },
      "dragging": false
    },
    {
      "id": "seqEnd_1",
      "position": {
        "x": 2369.0398121308936,
        "y": 1713.1417285578152
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_1",
        "label": "End",
        "version": 2.1,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "id": "seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqCustomFunction_1.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2369.0398121308936,
        "y": 1713.1417285578152
      },
      "dragging": false
    },
    {
      "id": "seqCustomFunction_1",
      "position": {
        "x": 2051.579201305265,
        "y": 1062.3586428398546
      },
      "type": "customNode",
      "data": {
        "id": "seqCustomFunction_1",
        "label": "Custom JS Function",
        "version": 1,
        "name": "seqCustomFunction",
        "type": "CustomFunction",
        "baseClasses": [
          "CustomFunction"
        ],
        "category": "Sequential Agents",
        "description": "Execute custom javascript function",
        "inputParams": [
          {
            "label": "Input Variables",
            "name": "functionInputVariables",
            "description": "Input variables can be used in the function with prefix $. For example: $var",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqCustomFunction_1-input-functionInputVariables-json"
          },
          {
            "label": "Function Name",
            "name": "functionName",
            "type": "string",
            "placeholder": "My Function",
            "id": "seqCustomFunction_1-input-functionName-string"
          },
          {
            "label": "Javascript Function",
            "name": "javascriptFunction",
            "type": "code",
            "hint": {
              "label": "How to use",
              "value": "\n1. Must return a string value at the end of function.\n\n2. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n3. You can get custom variables: `$vars.<variable-name>`\n\n"
            },
            "id": "seqCustomFunction_1-input-javascriptFunction-code"
          },
          {
            "label": "Return Value As",
            "name": "returnValueAs",
            "type": "options",
            "options": [
              {
                "label": "AI Message",
                "name": "aiMessage"
              },
              {
                "label": "Human Message",
                "name": "humanMessage"
              },
              {
                "label": "State Object",
                "name": "stateObj",
                "description": "Return as state object, ex: { foo: bar }. This will update the custom state 'foo' to 'bar'"
              }
            ],
            "default": "aiMessage",
            "id": "seqCustomFunction_1-input-returnValueAs-options"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "functionInputVariables": "{\"instruction\":\"$flow.state.instruction\"}",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "functionName": "MessageAskUser",
          "javascriptFunction": "return String($instruction)",
          "returnValueAs": "aiMessage"
        },
        "outputAnchors": [
          {
            "id": "seqCustomFunction_1-output-seqCustomFunction-CustomFunction",
            "name": "seqCustomFunction",
            "label": "CustomFunction",
            "description": "Execute custom javascript function",
            "type": "CustomFunction"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 795,
      "selected": false,
      "positionAbsolute": {
        "x": 2051.579201305265,
        "y": 1062.3586428398546
      },
      "dragging": false
    },
    {
      "id": "stickyNote_1",
      "position": {
        "x": 66.97275429770514,
        "y": 983.7498255438102
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_1",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_1-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Not adding long term chat memory because its not worth the effort, but feel free to add it.\n\nhttps://langchain-ai.github.io/langgraph/concepts/memory/#long-term-memory"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_1-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 163,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 66.97275429770514,
        "y": 983.7498255438102
      }
    },
    {
      "id": "plainText_0",
      "position": {
        "x": 376.2635886620957,
        "y": 1983.761408512896
      },
      "type": "customNode",
      "data": {
        "id": "plainText_0",
        "label": "Plain Text",
        "version": 2,
        "name": "plainText",
        "type": "Document",
        "baseClasses": [
          "Document"
        ],
        "category": "Document Loaders",
        "description": "Load data from plain text",
        "inputParams": [
          {
            "label": "Text",
            "name": "text",
            "type": "string",
            "rows": 4,
            "placeholder": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua...",
            "id": "plainText_0-input-text-string"
          },
          {
            "label": "Additional Metadata",
            "name": "metadata",
            "type": "json",
            "description": "Additional metadata to be added to the extracted documents",
            "optional": true,
            "additionalParams": true,
            "id": "plainText_0-input-metadata-json"
          },
          {
            "label": "Omit Metadata Keys",
            "name": "omitMetadataKeys",
            "type": "string",
            "rows": 4,
            "description": "Each document loader comes with a default set of metadata keys that are extracted from the document. You can use this field to omit some of the default metadata keys. The value should be a list of keys, separated by comma. Use * to omit all metadata keys execept the ones you specify in the Additional Metadata field",
            "placeholder": "key1, key2, key3.nestedKey1",
            "optional": true,
            "additionalParams": true,
            "id": "plainText_0-input-omitMetadataKeys-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Text Splitter",
            "name": "textSplitter",
            "type": "TextSplitter",
            "optional": true,
            "id": "plainText_0-input-textSplitter-TextSplitter"
          }
        ],
        "inputs": {
          "text": "false",
          "textSplitter": "",
          "metadata": "",
          "omitMetadataKeys": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "Array of document objects containing metadata and pageContent",
            "options": [
              {
                "id": "plainText_0-output-document-Document|json",
                "name": "document",
                "label": "Document",
                "description": "Array of document objects containing metadata and pageContent",
                "type": "Document | json"
              },
              {
                "id": "plainText_0-output-text-string|json",
                "name": "text",
                "label": "Text",
                "description": "Concatenated string from pageContent of documents",
                "type": "string | json"
              }
            ],
            "default": "document"
          }
        ],
        "outputs": {
          "output": "text"
        },
        "selected": false
      },
      "width": 300,
      "height": 487,
      "positionAbsolute": {
        "x": 376.2635886620957,
        "y": 1983.761408512896
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "setVariable_1",
      "position": {
        "x": 693.8272478963587,
        "y": 1986.4217104601396
      },
      "type": "customNode",
      "data": {
        "id": "setVariable_1",
        "label": "Set Variable",
        "version": 2.1,
        "name": "setVariable",
        "type": "SetVariable",
        "baseClasses": [
          "SetVariable",
          "Utilities"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Set variable which can be retrieved at a later stage. Variable is only available during runtime.",
        "inputParams": [
          {
            "label": "Variable Name",
            "name": "variableName",
            "type": "string",
            "placeholder": "var1",
            "id": "setVariable_1-input-variableName-string"
          },
          {
            "label": "Show Output",
            "name": "showOutput",
            "description": "Show the output result in the Prediction API response",
            "type": "boolean",
            "optional": true,
            "additionalParams": true,
            "id": "setVariable_1-input-showOutput-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Input",
            "name": "input",
            "type": "string | number | boolean | json | array",
            "optional": true,
            "list": true,
            "id": "setVariable_1-input-input-string | number | boolean | json | array"
          }
        ],
        "inputs": {
          "input": [
            "{{plainText_0.data.instance}}"
          ],
          "variableName": "is_nextjs_runtime_available",
          "showOutput": ""
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "description": "",
            "options": [
              {
                "id": "setVariable_1-output-output-string|number|boolean|json|array",
                "name": "output",
                "label": "Output",
                "description": "",
                "type": "string | number | boolean | json | array"
              }
            ],
            "default": "output"
          }
        ],
        "outputs": {
          "output": "output"
        },
        "selected": false
      },
      "width": 300,
      "height": 408,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 693.8272478963587,
        "y": 1986.4217104601396
      }
    },
    {
      "id": "stickyNote_2",
      "position": {
        "x": 378.14658030429007,
        "y": 1909.8763514699885
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_2",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_2-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Enable or disable nextjs runtime. Once enabled cannot be disabled"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_2-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 62,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 378.14658030429007,
        "y": 1909.8763514699885
      }
    },
    {
      "id": "stickyNote_3",
      "position": {
        "x": 1030.2376937088827,
        "y": -132.8837439477482
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_3",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_3-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "Add a document store here, to add multiple, duplicate from retriever tool. 1 store per tool"
        },
        "outputAnchors": [
          {
            "id": "stickyNote_3-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 82,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 1030.2376937088827,
        "y": -132.8837439477482
      }
    },
    {
      "id": "seqLLMNode_5",
      "position": {
        "x": 2057.696721767833,
        "y": 71.29030790710411
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_5",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_5-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_5-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_5-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_5-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_5-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "FileSystemManager",
          "systemMessagePrompt": "You are a file system expert who can manipulate and organize digital content. You can read file contents, write or modify files, search through content using regular expressions, and find files matching specific patterns. Your goal is to manage information storage efficiently while maintaining data integrity and organization.\n\nIMPORTANT: Always pass empty string as content for file_write if the instructions of the message instructs to create a file and/or specify its contents.\nDEFAULT_FS_OPS_DIR=/mnt/data",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "",
          "llmStructuredOutput": "",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_5-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 2057.696721767833,
        "y": 71.29030790710411
      },
      "dragging": false
    },
    {
      "id": "seqToolNode_1",
      "position": {
        "x": 2373.044490358755,
        "y": 69.61782448259922
      },
      "type": "customNode",
      "data": {
        "id": "seqToolNode_1",
        "label": "Tool Node",
        "version": 2.1,
        "name": "seqToolNode",
        "type": "ToolNode",
        "baseClasses": [
          "ToolNode"
        ],
        "category": "Sequential Agents",
        "description": "Execute tool and return tool's output",
        "inputParams": [
          {
            "label": "Name",
            "name": "toolNodeName",
            "type": "string",
            "placeholder": "Tool",
            "id": "seqToolNode_1-input-toolNodeName-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Require approval before executing tools",
            "type": "boolean",
            "optional": true,
            "id": "seqToolNode_1-input-interrupt-boolean"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqToolNode_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Tool Node's output as the value to update state, it is available as available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    | Key          | Value                                     |\n    |--------------|-------------------------------------------|\n    | sources      | `$flow.output[0].toolOutput`       |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "All Tools Output (array)",
                        "value": "$flow.output"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output[0].toolOutput"
                      },
                      {
                        "label": "First Tool Input Arguments (string | json)",
                        "value": "$flow.output[0].toolInput"
                      },
                      {
                        "label": "First Tool Returned Source Documents (array)",
                        "value": "$flow.output[0].sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the tool's output as the value to update state, it is available as `$flow.output` with the following structure (array):\n    ```json\n    [\n        {\n            \"tool\": \"tool's name\",\n            \"toolInput\": {},\n            \"toolOutput\": \"tool's output content\",\n            \"sourceDocuments\": [\n                {\n                    \"pageContent\": \"This is the page content\",\n                    \"metadata\": \"{foo: var}\"\n                }\n            ]\n        }\n    ]\n    ```\n\n    For example:\n    ```js\n    /* Assuming you have the following state:\n    {\n        \"sources\": null\n    }\n    */\n    \n    return {\n        \"sources\": $flow.output[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After tool execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqToolNode_1-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqToolNode_1-input-tools-Tool"
          },
          {
            "label": "LLM Node",
            "name": "llmNode",
            "type": "LLMNode",
            "id": "seqToolNode_1-input-llmNode-LLMNode"
          }
        ],
        "inputs": {
          "tools": [
            "{{customMCP_1.data.instance}}"
          ],
          "llmNode": "{{seqLLMNode_5.data.instance}}",
          "toolNodeName": "fs",
          "interrupt": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI"
        },
        "outputAnchors": [
          {
            "id": "seqToolNode_1-output-seqToolNode-ToolNode",
            "name": "seqToolNode",
            "label": "ToolNode",
            "description": "Execute tool and return tool's output",
            "type": "ToolNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 529,
      "selected": false,
      "positionAbsolute": {
        "x": 2373.044490358755,
        "y": 69.61782448259922
      },
      "dragging": false
    },
    {
      "id": "seqCondition_1",
      "position": {
        "x": 2683.892017306258,
        "y": 28.52519991198689
      },
      "type": "customNode",
      "data": {
        "id": "seqCondition_1",
        "label": "Condition",
        "version": 2.1,
        "name": "seqCondition",
        "type": "Condition",
        "baseClasses": [
          "Condition"
        ],
        "category": "Sequential Agents",
        "description": "Conditional function to determine which route to take next",
        "inputParams": [
          {
            "label": "Condition Name",
            "name": "conditionName",
            "type": "string",
            "optional": true,
            "placeholder": "If X, then Y",
            "id": "seqCondition_1-input-conditionName-string"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const state = $flow.state;\n                \nconst messages = state.messages;\n\nconst lastMessage = messages[messages.length - 1];\n\n/* Check if the last message has content */\nif (lastMessage.content) {\n    return \"Agent\";\n}\n\nreturn \"End\";",
                "optional": true
              }
            ],
            "id": "seqCondition_1-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "conditionName": "return direct",
          "sequentialNode": [
            "{{seqToolNode_1.data.instance}}"
          ],
          "condition": "",
          "conditionFunction": "const state = $flow.state;\n                \nconst messages = state.messages;\nconst lastMessage = messages[messages.length - 1];\n/* Check if the last message has content */\nif (lastMessage.tool && [\"file_read\", \"file_read_image\"].includes(lastMessage.tool)) {\n    return \"true\";\n} else if (lastMessage.tool === \"file_write\" && lastMessage.toolOutput === \"\") {\n    return \"write_file_content\";\n} else if (lastMessage.tool && [].includes(lastMessage.tool)) {\n    return \"FileSystemManager\"\n}\nreturn \"false\";",
          "selectedConditionFunctionTab_seqCondition_1": "conditionFunction"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqCondition_1-output-filesystemmanager-Condition",
                "name": "filesystemmanager",
                "label": "FileSystemManager",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-false-Condition",
                "name": "false",
                "label": "false",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-true-Condition",
                "name": "true",
                "label": "true",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_1-output-write_file_content-Condition",
                "name": "write_file_content",
                "label": "write_file_content",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 577,
      "selected": false,
      "positionAbsolute": {
        "x": 2683.892017306258,
        "y": 28.52519991198689
      },
      "dragging": false
    },
    {
      "id": "seqLoop_7",
      "position": {
        "x": 3638.153212587294,
        "y": -503.18022819201246
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_7",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_7-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "FileSystemManager"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3638.153212587294,
        "y": -503.18022819201246
      },
      "dragging": false
    },
    {
      "id": "seqAgent_0",
      "position": {
        "x": 3009.655853862086,
        "y": -258.243554717272
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_0",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_0-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_0-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_0-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_0-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_0-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "write_file_content",
          "systemMessagePrompt": "You are an expert at synthesizing content according to the provided instructions and conversation history.\n{instruction}\nWhen receiving a content creation instruction, assess whether adequate research has been done. If not, recommend returning to research phase first.\n\nFile write strategy: Overwrite contents",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_3.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{\"instruction\":\"$flow.state.instruction\"}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_0-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 860,
      "positionAbsolute": {
        "x": 3009.655853862086,
        "y": -258.243554717272
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "customMCP_3",
      "position": {
        "x": 2677.596515725679,
        "y": -632.9773525385917
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_3",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_3-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_3-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bunx\",\n  \"args\": [\n    \"-y\",\n    \"supergateway\",\n    \"--sse\",\n    \"http://localhost:8002/sse\"\n  ]\n}",
          "mcpActions": "[\"file_write\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_3-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 546,
      "selected": false,
      "positionAbsolute": {
        "x": 2677.596515725679,
        "y": -632.9773525385917
      },
      "dragging": false
    },
    {
      "id": "seqLoop_8",
      "position": {
        "x": 3329.9258801279134,
        "y": 361.27391026223324
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_8",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_8-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_0.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3329.9258801279134,
        "y": 361.27391026223324
      },
      "dragging": false
    },
    {
      "id": "stickyNote_4",
      "position": {
        "x": 3324.2771152202763,
        "y": -260.2039355346217
      },
      "type": "stickyNote",
      "data": {
        "id": "stickyNote_4",
        "label": "Sticky Note",
        "version": 2,
        "name": "stickyNote",
        "type": "StickyNote",
        "baseClasses": [
          "StickyNote"
        ],
        "tags": [
          "Utilities"
        ],
        "category": "Utilities",
        "description": "Add a sticky note",
        "inputParams": [
          {
            "label": "",
            "name": "note",
            "type": "string",
            "rows": 1,
            "placeholder": "Type something here",
            "optional": true,
            "id": "stickyNote_4-input-note-string"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "note": "This is an expensive api call as it uses the entire message history as its context, this we need extra logic to only invoke it when required."
        },
        "outputAnchors": [
          {
            "id": "stickyNote_4-output-stickyNote-StickyNote",
            "name": "stickyNote",
            "label": "StickyNote",
            "description": "Add a sticky note",
            "type": "StickyNote"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 103,
      "selected": false,
      "dragging": false,
      "positionAbsolute": {
        "x": 3324.2771152202763,
        "y": -260.2039355346217
      }
    },
    {
      "id": "seqLoop_9",
      "position": {
        "x": 3322.6618117394037,
        "y": -505.6660585939353
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_9",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_9-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqCondition_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 242,
      "selected": false,
      "positionAbsolute": {
        "x": 3322.6618117394037,
        "y": -505.6660585939353
      },
      "dragging": false
    }
  ],
  "edges": [
    {
      "source": "sqliteAgentMemory_0",
      "sourceHandle": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "type": "buttonedge",
      "id": "sqliteAgentMemory_0-sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver-seqStart_0-seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "selected": false
    },
    {
      "source": "seqState_0",
      "sourceHandle": "seqState_0-output-seqState-State",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-state-State",
      "type": "buttonedge",
      "id": "seqState_0-seqState_0-output-seqState-State-seqStart_0-seqStart_0-input-state-State",
      "selected": false
    },
    {
      "source": "seqLLMNode_0",
      "sourceHandle": "seqLLMNode_0-output-seqLLMNode-LLMNode",
      "target": "seqCondition_0",
      "targetHandle": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_0-seqLLMNode_0-output-seqLLMNode-LLMNode-seqCondition_0-seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "braveSearchAPI_0",
      "sourceHandle": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "braveSearchAPI_0-braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable-seqAgent_2-seqAgent_2-input-tools-Tool",
      "selected": false
    },
    {
      "source": "customMCP_0",
      "sourceHandle": "customMCP_0-output-customMCP-Tool",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_0-customMCP_0-output-customMCP-Tool-seqAgent_2-seqAgent_2-input-tools-Tool",
      "selected": false
    },
    {
      "source": "customMCP_2",
      "sourceHandle": "customMCP_2-output-customMCP-Tool",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_2-customMCP_2-output-customMCP-Tool-seqAgent_1-seqAgent_1-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-webnavigator-Condition",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-webnavigator-Condition-seqAgent_2-seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-commandrunner-Condition",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-commandrunner-Condition-seqAgent_1-seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-end-Condition",
      "target": "seqEnd_0",
      "targetHandle": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-end-Condition-seqEnd_0-seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-planmanager-Condition",
      "target": "seqLLMNode_1",
      "targetHandle": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-planmanager-Condition-seqLLMNode_1-seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "unstructuredFileLoader_0",
      "sourceHandle": "unstructuredFileLoader_0-output-document-Document|json",
      "target": "setVariable_0",
      "targetHandle": "setVariable_0-input-input-string | number | boolean | json | array",
      "type": "buttonedge",
      "id": "unstructuredFileLoader_0-unstructuredFileLoader_0-output-document-Document|json-setVariable_0-setVariable_0-input-input-string | number | boolean | json | array",
      "selected": false
    },
    {
      "source": "seqAgent_1",
      "sourceHandle": "seqAgent_1-output-seqAgent-Agent",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_1-seqAgent_1-output-seqAgent-Agent-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqLLMNode_3",
      "sourceHandle": "seqLLMNode_3-output-seqLLMNode-LLMNode",
      "target": "seqLoop_1",
      "targetHandle": "seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_3-seqLLMNode_3-output-seqLLMNode-LLMNode-seqLoop_1-seqLoop_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-rewrite-Condition",
      "target": "seqLLMNode_3",
      "targetHandle": "seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-rewrite-Condition-seqLLMNode_3-seqLLMNode_3-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-generate-Condition",
      "target": "seqLLMNode_2",
      "targetHandle": "seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-generate-Condition-seqLLMNode_2-seqLLMNode_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "documentStoreVS_0",
      "sourceHandle": "documentStoreVS_0-output-retriever-BaseRetriever",
      "target": "retrieverTool_0",
      "targetHandle": "retrieverTool_0-input-retriever-BaseRetriever",
      "type": "buttonedge",
      "id": "documentStoreVS_0-documentStoreVS_0-output-retriever-BaseRetriever-retrieverTool_0-retrieverTool_0-input-retriever-BaseRetriever",
      "selected": false
    },
    {
      "source": "seqToolNode_0",
      "sourceHandle": "seqToolNode_0-output-seqToolNode-ToolNode",
      "target": "seqConditionAgent_0",
      "targetHandle": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqToolNode_0-seqToolNode_0-output-seqToolNode-ToolNode-seqConditionAgent_0-seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "retrieverTool_0",
      "sourceHandle": "retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable",
      "target": "seqToolNode_0",
      "targetHandle": "seqToolNode_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "retrieverTool_0-retrieverTool_0-output-retrieverTool-RetrieverTool|DynamicTool|Tool|StructuredTool|Runnable-seqToolNode_0-seqToolNode_0-input-tools-Tool",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-knowledgebase-Condition",
      "target": "seqLLMNode_4",
      "targetHandle": "seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-knowledgebase-Condition-seqLLMNode_4-seqLLMNode_4-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqLLMNode_4",
      "sourceHandle": "seqLLMNode_4-output-seqLLMNode-LLMNode",
      "target": "seqToolNode_0",
      "targetHandle": "seqToolNode_0-input-llmNode-LLMNode",
      "type": "buttonedge",
      "id": "seqLLMNode_4-seqLLMNode_4-output-seqLLMNode-LLMNode-seqToolNode_0-seqToolNode_0-input-llmNode-LLMNode",
      "selected": false
    },
    {
      "source": "seqLLMNode_1",
      "sourceHandle": "seqLLMNode_1-output-seqLLMNode-LLMNode",
      "target": "seqLoop_3",
      "targetHandle": "seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_1-seqLLMNode_1-output-seqLLMNode-LLMNode-seqLoop_3-seqLoop_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqAgent_2",
      "sourceHandle": "seqAgent_2-output-seqAgent-Agent",
      "target": "seqLoop_4",
      "targetHandle": "seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_2-seqAgent_2-output-seqAgent-Agent-seqLoop_4-seqLoop_4-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqLLMNode_2",
      "sourceHandle": "seqLLMNode_2-output-seqLLMNode-LLMNode",
      "target": "seqLoop_5",
      "targetHandle": "seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_2-seqLLMNode_2-output-seqLLMNode-LLMNode-seqLoop_5-seqLoop_5-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCustomFunction_0",
      "sourceHandle": "seqCustomFunction_0-output-seqCustomFunction-CustomFunction",
      "target": "seqLoop_6",
      "targetHandle": "seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCustomFunction_0-seqCustomFunction_0-output-seqCustomFunction-CustomFunction-seqLoop_6-seqLoop_6-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCustomFunction_1",
      "sourceHandle": "seqCustomFunction_1-output-seqCustomFunction-CustomFunction",
      "target": "seqEnd_1",
      "targetHandle": "seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCustomFunction_1-seqCustomFunction_1-output-seqCustomFunction-CustomFunction-seqEnd_1-seqEnd_1-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-messageaskuser-Condition",
      "target": "seqCustomFunction_1",
      "targetHandle": "seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-messageaskuser-Condition-seqCustomFunction_1-seqCustomFunction_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-messagenotifyuser-Condition",
      "target": "seqCustomFunction_0",
      "targetHandle": "seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-messagenotifyuser-Condition-seqCustomFunction_0-seqCustomFunction_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "chatAnthropic_0",
      "sourceHandle": "chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-model-BaseChatModel",
      "type": "buttonedge",
      "id": "chatAnthropic_0-chatAnthropic_0-output-chatAnthropic-ChatAnthropic|ChatAnthropicMessages|BaseChatModel|BaseLanguageModel|Runnable-seqStart_0-seqStart_0-input-model-BaseChatModel",
      "selected": false
    },
    {
      "source": "seqStart_0",
      "sourceHandle": "seqStart_0-output-seqStart-Start",
      "target": "seqLLMNode_0",
      "targetHandle": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqStart_0-seqStart_0-output-seqStart-Start-seqLLMNode_0-seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "plainText_0",
      "sourceHandle": "plainText_0-output-document-Document|json",
      "target": "setVariable_1",
      "targetHandle": "setVariable_1-input-input-string | number | boolean | json | array",
      "type": "buttonedge",
      "id": "plainText_0-plainText_0-output-document-Document|json-setVariable_1-setVariable_1-input-input-string | number | boolean | json | array"
    },
    {
      "source": "seqLLMNode_5",
      "sourceHandle": "seqLLMNode_5-output-seqLLMNode-LLMNode",
      "target": "seqToolNode_1",
      "targetHandle": "seqToolNode_1-input-llmNode-LLMNode",
      "type": "buttonedge",
      "id": "seqLLMNode_5-seqLLMNode_5-output-seqLLMNode-LLMNode-seqToolNode_1-seqToolNode_1-input-llmNode-LLMNode",
      "selected": false
    },
    {
      "source": "seqToolNode_1",
      "sourceHandle": "seqToolNode_1-output-seqToolNode-ToolNode",
      "target": "seqCondition_1",
      "targetHandle": "seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqToolNode_1-seqToolNode_1-output-seqToolNode-ToolNode-seqCondition_1-seqCondition_1-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-filesystemmanager-Condition",
      "target": "seqLLMNode_5",
      "targetHandle": "seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-filesystemmanager-Condition-seqLLMNode_5-seqLLMNode_5-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "customMCP_1",
      "sourceHandle": "customMCP_1-output-customMCP-Tool",
      "target": "seqToolNode_1",
      "targetHandle": "seqToolNode_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_1-customMCP_1-output-customMCP-Tool-seqToolNode_1-seqToolNode_1-input-tools-Tool"
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-write_file_content-Condition",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-write_file_content-Condition-seqAgent_0-seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "customMCP_3",
      "sourceHandle": "customMCP_3-output-customMCP-Tool",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_3-customMCP_3-output-customMCP-Tool-seqAgent_0-seqAgent_0-input-tools-Tool"
    },
    {
      "source": "seqAgent_0",
      "sourceHandle": "seqAgent_0-output-seqAgent-Agent",
      "target": "seqLoop_8",
      "targetHandle": "seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_0-seqAgent_0-output-seqAgent-Agent-seqLoop_8-seqLoop_8-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-true-Condition",
      "target": "seqLoop_2",
      "targetHandle": "seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-true-Condition-seqLoop_2-seqLoop_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-false-Condition",
      "target": "seqLoop_9",
      "targetHandle": "seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-false-Condition-seqLoop_9-seqLoop_9-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_1",
      "sourceHandle": "seqCondition_1-output-filesystemmanager-Condition",
      "target": "seqLoop_7",
      "targetHandle": "seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_1-seqCondition_1-output-filesystemmanager-Condition-seqLoop_7-seqLoop_7-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    }
  ]
}
